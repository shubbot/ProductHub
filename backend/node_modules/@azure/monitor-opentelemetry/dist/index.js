'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var api = require('@opentelemetry/api');
var apiLogs = require('@opentelemetry/api-logs');
var sdkNode = require('@opentelemetry/sdk-node');
var resources = require('@opentelemetry/resources');
var fs = require('fs');
var path = require('path');
var logger = require('@azure/logger');
var os = require('os');
var util = require('util');
var resourceDetectorAzure = require('@opentelemetry/resource-detector-azure');
var opentelemetryInstrumentationAzureSdk = require('@azure/opentelemetry-instrumentation-azure-sdk');
var monitorOpentelemetryExporter = require('@azure/monitor-opentelemetry-exporter');
var sdkTraceBase = require('@opentelemetry/sdk-trace-base');
var instrumentationHttp = require('@opentelemetry/instrumentation-http');
var instrumentationMongodb = require('@opentelemetry/instrumentation-mongodb');
var instrumentationMysql = require('@opentelemetry/instrumentation-mysql');
var instrumentationPg = require('@opentelemetry/instrumentation-pg');
var instrumentationRedis = require('@opentelemetry/instrumentation-redis');
var instrumentationRedis4 = require('@opentelemetry/instrumentation-redis-4');
var http = require('http');
var https = require('https');
var applicationinsightsWebSnippet = require('@microsoft/applicationinsights-web-snippet');
var zlib = require('zlib');
var semanticConventions = require('@opentelemetry/semantic-conventions');
var core = require('@opentelemetry/core');
var sdkMetrics = require('@opentelemetry/sdk-metrics');
var url = require('url');
var coreRestPipeline = require('@azure/core-rest-pipeline');
var coreClient = require('@azure/core-client');
var instrumentationBunyan = require('@opentelemetry/instrumentation-bunyan');
var instrumentationWinston = require('@opentelemetry/instrumentation-winston');
var sdkLogs = require('@opentelemetry/sdk-logs');

function _interopNamespaceDefault(e) {
    var n = Object.create(null);
    if (e) {
        Object.keys(e).forEach(function (k) {
            if (k !== 'default') {
                var d = Object.getOwnPropertyDescriptor(e, k);
                Object.defineProperty(n, k, d.get ? d : {
                    enumerable: true,
                    get: function () { return e[k]; }
                });
            }
        });
    }
    n.default = e;
    return Object.freeze(n);
}

var fs__namespace = /*#__PURE__*/_interopNamespaceDefault(fs);
var path__namespace = /*#__PURE__*/_interopNamespaceDefault(path);
var os__namespace = /*#__PURE__*/_interopNamespaceDefault(os);
var zlib__namespace = /*#__PURE__*/_interopNamespaceDefault(zlib);
var coreClient__namespace = /*#__PURE__*/_interopNamespaceDefault(coreClient);

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
const statAsync = util.promisify(fs__namespace.stat);
const lstatAsync = util.promisify(fs__namespace.lstat);
const mkdirAsync = util.promisify(fs__namespace.mkdir);
const accessAsync = util.promisify(fs__namespace.access);
const appendFileAsync = util.promisify(fs__namespace.appendFile);
const writeFileAsync = util.promisify(fs__namespace.writeFile);
const readFileAsync = util.promisify(fs__namespace.readFile);
const readdirAsync = util.promisify(fs__namespace.readdir);
const unlinkAsync = util.promisify(fs__namespace.unlink);
/**
 * Validate directory exists.
 */
const confirmDirExists = async (directory) => {
    try {
        const stats = await lstatAsync(directory);
        if (!stats.isDirectory()) {
            throw new Error("Path existed but was not a directory");
        }
    }
    catch (err) {
        if (err && err.code === "ENOENT") {
            try {
                await mkdirAsync(directory);
            }
            catch (mkdirErr) {
                if (mkdirErr && mkdirErr.code !== "EEXIST") {
                    // Handle race condition by ignoring EEXIST
                    throw mkdirErr;
                }
            }
        }
    }
};
/**
 * Computes the size (in bytes) of a file asynchronously.
 */
const getShallowFileSize = async (filePath) => {
    const fileStats = await statAsync(filePath);
    if (fileStats.isFile()) {
        return fileStats.size;
    }
    return null;
};

function ignoreOutgoingRequestHook(request) {
    if (request && request.headers) {
        if ((request.headers["User-Agent"] &&
            request.headers["User-Agent"]
                .toString()
                .indexOf("azsdk-js-monitor-opentelemetry-exporter") > -1) ||
            (request.headers["user-agent"] &&
                request.headers["user-agent"]
                    .toString()
                    .indexOf("azsdk-js-monitor-opentelemetry-exporter") > -1)) {
            return true;
        }
    }
    return false;
}
const isWindows = () => {
    return process.platform === "win32";
};
const isLinux = () => {
    return process.platform === "linux";
};
/**
 * Get prefix for OS
 * Windows system: "w"
 * Linux system: "l"
 * non-Windows and non-Linux system: "u" (unknown)
 */
const getOsPrefix = () => {
    return isWindows() ? "w" : isLinux() ? "l" : "u";
};
/**
 * Get prefix resource provider, vm will considered as "unknown RP"
 * Web App: "a"
 * Function App: "f"
 * non-Web and non-Function APP: "u" (unknown)
 */
const isAppService = () => {
    return process.env.WEBSITE_SITE_NAME && !process.env.FUNCTIONS_WORKER_RUNTIME ? true : false;
};
const isFunctionApp = () => {
    return process.env.FUNCTIONS_WORKER_RUNTIME ? true : false;
};
const isAks = () => {
    return process.env.AKS_ARM_NAMESPACE_ID || process.env.KUBERNETES_SERVICE_HOST ? true : false;
};
/**
 * Get prefix resource provider, vm will considered as "unknown RP"
 * Web App: "a"
 * Function App: "f"
 * AKS: "k"
 * non-Web and non-Function APP: "u" (unknown)
 */
const getResourceProvider = () => {
    if (isAppService()) {
        return "a";
    }
    if (isFunctionApp()) {
        return "f";
    }
    if (isAks()) {
        return "k";
    }
    return "u";
};
// This function is a slight modification of an upstream otel util function -
// mainly for prioritizing the resource detectors customer may specify over
// env var & not enabling process detector by default.
function parseResourceDetectorsFromEnvVar() {
    var _a, _b;
    const resourceDetectors = new Map([
        ["env", resources.envDetectorSync],
        ["host", resources.hostDetectorSync],
        ["os", resources.osDetectorSync],
        ["process", resources.processDetectorSync],
        ["serviceinstance", resources.serviceInstanceIdDetectorSync],
    ]);
    if (process.env.OTEL_NODE_RESOURCE_DETECTORS != null) {
        const resourceDetectorsFromEnv = (_b = (_a = process.env.OTEL_NODE_RESOURCE_DETECTORS) === null || _a === void 0 ? void 0 : _a.split(",")) !== null && _b !== void 0 ? _b : [
            "env",
            "host",
            "os",
        ];
        if (resourceDetectorsFromEnv.includes("all")) {
            return [...resourceDetectors.values()];
        }
        if (resourceDetectorsFromEnv.includes("none")) {
            return [];
        }
        return resourceDetectorsFromEnv.flatMap((detector) => {
            const resourceDetector = resourceDetectors.get(detector);
            if (!resourceDetector) {
                api.diag.error(`Invalid resource detector "${detector}" specified in the environment variable OTEL_NODE_RESOURCE_DETECTORS`);
                return [];
            }
            return [resourceDetector];
        });
    }
    else {
        // leaving out the process detector as that can add many resource attributes
        // with large values. Also not enabling service instance attributes by default
        // as this is still experimental.
        return [resources.envDetectorSync, resources.hostDetectorSync, resources.osDetectorSync];
    }
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
class DiagFileConsoleLogger {
    constructor() {
        this._TAG = "DiagFileConsoleLogger:";
        this._cleanupTimeOut = 60 * 30 * 1000; // 30 minutes;
        this._fileCleanupTimer = null;
        this._logToFile = false;
        this._logToConsole = true;
        this._logDestination = process.env.APPLICATIONINSIGHTS_LOG_DESTINATION; // destination can be one of file, console or file+console
        if (this._logDestination === "file+console") {
            this._logToFile = true;
        }
        if (this._logDestination === "file") {
            this._logToFile = true;
            this._logToConsole = false;
        }
        this._maxSizeBytes = 50000;
        this._maxHistory = 1;
        this._logFileName = "applicationinsights.log";
        // If custom path not provided use temp folder, /tmp for *nix and USERDIR/AppData/Local/Temp for Windows
        const logFilePath = process.env.APPLICATIONINSIGHTS_LOGDIR;
        if (!logFilePath) {
            this._tempDir = path__namespace.join(os__namespace.tmpdir(), "appInsights-node");
        }
        else {
            if (path__namespace.isAbsolute(logFilePath)) {
                this._tempDir = logFilePath;
            }
            else {
                this._tempDir = path__namespace.join(process.cwd(), logFilePath);
            }
        }
        this._fileFullPath = path__namespace.join(this._tempDir, this._logFileName);
        this._backUpNameFormat = `.${this._logFileName}`; // {currentime}.applicationinsights.log
        if (this._logToFile) {
            if (!this._fileCleanupTimer) {
                this._fileCleanupTimer = setInterval(() => {
                    // eslint-disable-next-line @typescript-eslint/no-floating-promises
                    this._fileCleanupTask();
                }, this._cleanupTimeOut);
                this._fileCleanupTimer.unref();
            }
        }
    }
    // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
    error(message, ...args) {
        // eslint-disable-next-line @typescript-eslint/no-floating-promises
        this.logMessage(message, args);
    }
    // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
    warn(message, ...args) {
        // eslint-disable-next-line @typescript-eslint/no-floating-promises
        this.logMessage(message, args);
    }
    // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
    info(message, ...args) {
        // eslint-disable-next-line @typescript-eslint/no-floating-promises
        this.logMessage(message, args);
    }
    // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
    debug(message, ...args) {
        // eslint-disable-next-line @typescript-eslint/no-floating-promises
        this.logMessage(message, args);
    }
    // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
    verbose(message, ...args) {
        // eslint-disable-next-line @typescript-eslint/no-floating-promises
        this.logMessage(message, args);
    }
    // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
    async logMessage(message, ...optionalParams) {
        try {
            const args = message ? [message, ...optionalParams] : optionalParams;
            if (this._logToFile) {
                await this._storeToDisk(args);
            }
            if (this._logToConsole) {
                // eslint-disable-next-line no-console
                console.log(...args);
            }
        }
        catch (err) {
            // eslint-disable-next-line no-console
            console.log(this._TAG, `Failed to log to file: ${err && err.message}`);
        }
    }
    async _storeToDisk(args) {
        const data = `${args}\r\n`;
        try {
            await confirmDirExists(this._tempDir);
        }
        catch (err) {
            // eslint-disable-next-line no-console
            console.log(this._TAG, `Failed to create directory for log file: ${err && err.message}`);
            return;
        }
        try {
            await accessAsync(this._fileFullPath, fs__namespace.constants.F_OK);
        }
        catch (err) {
            // No file create one
            try {
                await appendFileAsync(this._fileFullPath, data);
            }
            catch (appendError) {
                // eslint-disable-next-line no-console
                console.log(this._TAG, `Failed to put log into file: ${appendError && appendError.message}`);
                return;
            }
        }
        // Check size
        const size = await getShallowFileSize(this._fileFullPath);
        if (size && size > this._maxSizeBytes) {
            await this._createBackupFile(data);
        }
        else {
            await appendFileAsync(this._fileFullPath, data);
        }
    }
    async _createBackupFile(data) {
        try {
            const buffer = await readFileAsync(this._fileFullPath);
            const backupPath = path__namespace.join(this._tempDir, `${new Date().getTime()}.${this._logFileName}`);
            await writeFileAsync(backupPath, buffer);
        }
        catch (err) {
            // eslint-disable-next-line no-console
            console.log("Failed to generate backup log file", err);
        }
        finally {
            // Store logs
            // eslint-disable-next-line @typescript-eslint/no-floating-promises
            writeFileAsync(this._fileFullPath, data);
        }
    }
    async _fileCleanupTask() {
        try {
            let files = await readdirAsync(this._tempDir);
            // Filter only backup files
            files = files.filter((f) => path__namespace.basename(f).indexOf(this._backUpNameFormat) > -1);
            // Sort by creation date
            files.sort((a, b) => {
                // Check expiration
                const aCreationDate = new Date(parseInt(a.split(this._backUpNameFormat)[0]));
                const bCreationDate = new Date(parseInt(b.split(this._backUpNameFormat)[0]));
                if (aCreationDate < bCreationDate) {
                    return -1;
                }
                else {
                    return 1;
                }
            });
            const totalFiles = files.length;
            for (let i = 0; i < totalFiles - this._maxHistory; i++) {
                const pathToDelete = path__namespace.join(this._tempDir, files[i]);
                await unlinkAsync(pathToDelete);
            }
        }
        catch (err) {
            // eslint-disable-next-line no-console
            console.log(this._TAG, `Failed to cleanup log files: ${err && err.message}`);
        }
    }
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
class Logger {
    static getInstance() {
        if (!Logger.instance) {
            Logger.instance = new Logger();
        }
        return Logger.instance;
    }
    constructor() {
        this.azureLogger = logger.createClientLogger("@azure/monitor-opentelemetry");
        this.openTelemetryLogger = api.diag.createComponentLogger({
            namespace: "@azure/monitor-opentelemetry",
        });
        this.logToOpenTelemetry = true;
        this.logToAzureLogger = false;
        const otelLogLevelEnv = process.env.APPLICATIONINSIGHTS_INSTRUMENTATION_LOGGING_LEVEL || process.env.OTEL_LOG_LEVEL;
        this.diagLevel = api.DiagLogLevel.WARN; // Default
        switch (otelLogLevelEnv) {
            case "ALL":
                this.diagLevel = api.DiagLogLevel.ALL;
                break;
            case "DEBUG":
                this.diagLevel = api.DiagLogLevel.DEBUG;
                break;
            case "ERROR":
                this.diagLevel = api.DiagLogLevel.ERROR;
                break;
            case "INFO":
                this.diagLevel = api.DiagLogLevel.INFO;
                break;
            case "NONE":
                this.diagLevel = api.DiagLogLevel.NONE;
                break;
            case "VERBOSE":
                this.diagLevel = api.DiagLogLevel.VERBOSE;
                break;
            case "WARN":
                this.diagLevel = api.DiagLogLevel.WARN;
                break;
        }
        // Set OpenTelemetry Logger
        const fileConsoleLogger = new DiagFileConsoleLogger();
        api.diag.setLogger(fileConsoleLogger, {
            logLevel: this.diagLevel,
            suppressOverrideMessage: true,
        });
        const azureLogLevelEnv = process.env.APPLICATIONINSIGHTS_INSTRUMENTATION_LOGGING_LEVEL;
        switch (azureLogLevelEnv) {
            // Application Insights levels
            case "VERBOSE":
                logger.setLogLevel("verbose");
                break;
            case "INFO":
                logger.setLogLevel("info");
                break;
            case "WARN":
                logger.setLogLevel("warning");
                break;
            case "ERROR":
                logger.setLogLevel("error");
                break;
            default:
                logger.setLogLevel(process.env.AZURE_LOG_LEVEL || "warning");
                break;
        }
        // Override Azure logger
        logger.AzureLogger.log = (...args) => {
            fileConsoleLogger.logMessage(...args);
        };
    }
    // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
    error(message, ...args) {
        if (this.logToAzureLogger) {
            this.azureLogger.error(message, args);
        }
        if (this.logToOpenTelemetry) {
            this.openTelemetryLogger.error(message, args);
        }
    }
    // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
    warn(message, ...args) {
        if (this.logToAzureLogger) {
            this.azureLogger.warning(message, args);
        }
        if (this.logToOpenTelemetry) {
            this.openTelemetryLogger.warn(message, args);
        }
    }
    // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
    info(message, ...args) {
        if (this.logToAzureLogger) {
            this.azureLogger.info(message, args);
        }
        if (this.logToOpenTelemetry) {
            this.openTelemetryLogger.info(message, args);
        }
    }
    // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
    debug(message, ...args) {
        if (this.logToAzureLogger) {
            this.azureLogger.verbose(message, args);
        }
        if (this.logToOpenTelemetry) {
            this.openTelemetryLogger.debug(message, args);
        }
    }
    // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
    verbose(message, ...args) {
        if (this.logToAzureLogger) {
            this.azureLogger.verbose(message, args);
        }
        if (this.logToOpenTelemetry) {
            this.openTelemetryLogger.verbose(message, args);
        }
    }
    setLogToAzureLogger(value) {
        this.logToAzureLogger = value;
    }
    setLogToOpenTelemetry(value) {
        this.logToOpenTelemetry = value;
    }
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/* eslint-disable no-underscore-dangle*/
const ENV_CONFIGURATION_FILE = "APPLICATIONINSIGHTS_CONFIGURATION_FILE";
const ENV_CONTENT = "APPLICATIONINSIGHTS_CONFIGURATION_CONTENT";
/**
 * Azure Monitor OpenTelemetry Client Configuration through JSON File
 * @internal
 */
class JsonConfig {
    /** Get Singleton instance */
    static getInstance() {
        if (!JsonConfig._instance) {
            JsonConfig._instance = new JsonConfig();
        }
        return JsonConfig._instance;
    }
    /**
     * Initializes a new instance of the JsonConfig class.
     */
    constructor() {
        let jsonString = "";
        this._tempDir = "";
        const contentJsonConfig = process.env[ENV_CONTENT];
        // JSON string added directly in env variable
        if (contentJsonConfig) {
            jsonString = contentJsonConfig;
        }
        // JSON file
        else {
            const configFileName = "applicationinsights.json";
            const rootPath = path__namespace.join(__dirname, "../../../"); // Root of folder (__dirname = ../dist-esm/src)
            this._tempDir = path__namespace.join(rootPath, configFileName); // default
            const configFile = process.env[ENV_CONFIGURATION_FILE];
            if (configFile) {
                if (path__namespace.isAbsolute(configFile)) {
                    this._tempDir = configFile;
                }
                else {
                    this._tempDir = path__namespace.join(rootPath, configFile); // Relative path to applicationinsights folder
                }
            }
            try {
                jsonString = fs__namespace.readFileSync(this._tempDir, "utf8");
            }
            catch (err) {
                Logger.getInstance().info("Failed to read JSON config file: ", err);
            }
        }
        try {
            const jsonConfig = JSON.parse(jsonString);
            this.azureMonitorExporterOptions = jsonConfig.azureMonitorExporterOptions;
            this.samplingRatio = jsonConfig.samplingRatio;
            this.instrumentationOptions = jsonConfig.instrumentationOptions;
            this.browserSdkLoaderOptions = jsonConfig.browserSdkLoaderOptions;
            this.enableLiveMetrics = jsonConfig.enableLiveMetrics;
            this.enableStandardMetrics = jsonConfig.enableStandardMetrics;
            this.enableTraceBasedSamplingForLogs = jsonConfig.enableTraceBasedSamplingForLogs;
        }
        catch (err) {
            Logger.getInstance().info("Missing or invalid JSON config file: ", err);
        }
    }
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * Azure Monitor OpenTelemetry Client Configuration
 */
class InternalConfig {
    set resource(resource) {
        this._resource = this._resource.merge(resource);
    }
    /**
     *Get OpenTelemetry Resource
     */
    get resource() {
        return this._resource;
    }
    /**
     * Initializes a new instance of the AzureMonitorOpenTelemetryOptions class.
     */
    constructor(options) {
        this._resource = resources.Resource.empty();
        // Default values
        this.azureMonitorExporterOptions = {};
        this.samplingRatio = 1;
        this.enableLiveMetrics = true;
        this.enableStandardMetrics = true;
        this.enableTraceBasedSamplingForLogs = false;
        this.instrumentationOptions = {
            http: { enabled: true },
            azureSdk: { enabled: false },
            mongoDb: { enabled: false },
            mySql: { enabled: false },
            postgreSql: { enabled: false },
            redis: { enabled: false },
            redis4: { enabled: false },
        };
        this._setDefaultResource();
        this.browserSdkLoaderOptions = {
            enabled: false,
            connectionString: "",
        };
        if (options) {
            // Merge default with provided options
            this.azureMonitorExporterOptions = Object.assign(this.azureMonitorExporterOptions, options.azureMonitorExporterOptions);
            this.instrumentationOptions = Object.assign(this.instrumentationOptions, options.instrumentationOptions);
            this.resource = Object.assign(this.resource, options.resource);
            this.samplingRatio =
                options.samplingRatio !== undefined ? options.samplingRatio : this.samplingRatio;
            this.browserSdkLoaderOptions = Object.assign(this.browserSdkLoaderOptions, options.browserSdkLoaderOptions);
            this.enableLiveMetrics =
                options.enableLiveMetrics !== undefined
                    ? options.enableLiveMetrics
                    : this.enableLiveMetrics;
            this.enableStandardMetrics =
                options.enableStandardMetrics !== undefined
                    ? options.enableStandardMetrics
                    : this.enableStandardMetrics;
            this.enableTraceBasedSamplingForLogs =
                options.enableTraceBasedSamplingForLogs !== undefined
                    ? options.enableTraceBasedSamplingForLogs
                    : this.enableTraceBasedSamplingForLogs;
        }
        // JSON configuration will take precedence over other settings
        this._mergeConfig();
    }
    _mergeConfig() {
        try {
            const jsonConfig = JsonConfig.getInstance();
            this.samplingRatio =
                jsonConfig.samplingRatio !== undefined ? jsonConfig.samplingRatio : this.samplingRatio;
            this.browserSdkLoaderOptions = Object.assign(this.browserSdkLoaderOptions, jsonConfig.browserSdkLoaderOptions);
            this.enableLiveMetrics =
                jsonConfig.enableLiveMetrics !== undefined
                    ? jsonConfig.enableLiveMetrics
                    : this.enableLiveMetrics;
            this.enableStandardMetrics =
                jsonConfig.enableStandardMetrics !== undefined
                    ? jsonConfig.enableStandardMetrics
                    : this.enableStandardMetrics;
            this.enableTraceBasedSamplingForLogs =
                jsonConfig.enableTraceBasedSamplingForLogs !== undefined
                    ? jsonConfig.enableTraceBasedSamplingForLogs
                    : this.enableTraceBasedSamplingForLogs;
            this.azureMonitorExporterOptions = Object.assign(this.azureMonitorExporterOptions, jsonConfig.azureMonitorExporterOptions);
            this.instrumentationOptions = Object.assign(this.instrumentationOptions, jsonConfig.instrumentationOptions);
        }
        catch (error) {
            Logger.getInstance().error("Failed to load JSON config file values.", error);
        }
    }
    _setDefaultResource() {
        var _a;
        let resource = resources.Resource.default();
        // Load resource attributes from env
        const detectResourceConfig = {
            detectors: [resources.envDetectorSync],
        };
        const envResource = resources.detectResourcesSync(detectResourceConfig);
        resource = resource.merge(envResource);
        // Load resource attributes from Azure
        const azureResource = resources.detectResourcesSync({
            detectors: [resourceDetectorAzure.azureAppServiceDetector, resourceDetectorAzure.azureFunctionsDetector],
        });
        this._resource = resource.merge(azureResource);
        const vmResource = resources.detectResourcesSync({
            detectors: [resourceDetectorAzure.azureVmDetector],
        });
        if (vmResource.asyncAttributesPending) {
            (_a = vmResource.waitForAsyncAttributes) === null || _a === void 0 ? void 0 : _a.call(vmResource).then(() => {
                this._resource = this._resource.merge(vmResource);
                return;
            });
        }
    }
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * Disable Standard Metrics environment variable name.
 */
const APPLICATION_INSIGHTS_NO_STANDARD_METRICS = "APPLICATION_INSIGHTS_NO_STANDARD_METRICS";
var PerformanceCounterMetricNames;
(function (PerformanceCounterMetricNames) {
    PerformanceCounterMetricNames["PRIVATE_BYTES"] = "Private_Bytes";
    PerformanceCounterMetricNames["AVAILABLE_BYTES"] = "Available_Bytes";
    PerformanceCounterMetricNames["PROCESSOR_TIME"] = "Processor_Time";
    PerformanceCounterMetricNames["PROCESS_TIME"] = "Process_Time";
    PerformanceCounterMetricNames["REQUEST_RATE"] = "Request_Rate";
    PerformanceCounterMetricNames["REQUEST_DURATION"] = "Request_Execution_Time";
})(PerformanceCounterMetricNames || (PerformanceCounterMetricNames = {}));
const StandardMetricPropertyNames = {
    cloudRoleInstance: "cloud/roleInstance",
    cloudRoleName: "cloud/roleName",
    operationSynthetic: "operation/synthetic",
    requestSuccess: "Request.Success",
    requestResultCode: "request/resultCode",
    dependencyType: "Dependency.Type",
    dependencyTarget: "dependency/target",
    dependencySuccess: "Dependency.Success",
    dependencyResultCode: "dependency/resultCode",
    traceSeverityLevel: "trace/severityLevel",
    metricId: "_MS.MetricId",
    IsAutocollected: "_MS.IsAutocollected",
};
var StandardMetricIds;
(function (StandardMetricIds) {
    StandardMetricIds["REQUEST_DURATION"] = "requests/duration";
    StandardMetricIds["DEPENDENCIES_DURATION"] = "dependencies/duration";
    StandardMetricIds["EXCEPTIONS_COUNT"] = "exceptions/count";
    StandardMetricIds["TRACES_COUNT"] = "traces/count";
})(StandardMetricIds || (StandardMetricIds = {}));

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Known values of {@link DocumentType} that the service accepts. */
var KnownDocumentType;
(function (KnownDocumentType) {
    /** Represents a request telemetry type. */
    KnownDocumentType["Request"] = "Request";
    /** Represents a remote dependency telemetry type. */
    KnownDocumentType["RemoteDependency"] = "RemoteDependency";
    /** Represents an exception telemetry type. */
    KnownDocumentType["Exception"] = "Exception";
    /** Represents an event telemetry type. */
    KnownDocumentType["Event"] = "Event";
    /** Represents a trace telemetry type. */
    KnownDocumentType["Trace"] = "Trace";
    /** Represents an unknown telemetry type. */
    KnownDocumentType["Unknown"] = "Unknown";
})(KnownDocumentType || (KnownDocumentType = {}));
/** Known values of {@link CollectionConfigurationErrorType} that the service accepts. */
var KnownCollectionConfigurationErrorType;
(function (KnownCollectionConfigurationErrorType) {
    /** Unknown error type. */
    KnownCollectionConfigurationErrorType["Unknown"] = "Unknown";
    /** Performance counter parsing error. */
    KnownCollectionConfigurationErrorType["PerformanceCounterParsing"] = "PerformanceCounterParsing";
    /** Performance counter unexpected error. */
    KnownCollectionConfigurationErrorType["PerformanceCounterUnexpected"] = "PerformanceCounterUnexpected";
    /** Performance counter duplicate ids. */
    KnownCollectionConfigurationErrorType["PerformanceCounterDuplicateIds"] = "PerformanceCounterDuplicateIds";
    /** Document stream duplication ids. */
    KnownCollectionConfigurationErrorType["DocumentStreamDuplicateIds"] = "DocumentStreamDuplicateIds";
    /** Document stream failed to create. */
    KnownCollectionConfigurationErrorType["DocumentStreamFailureToCreate"] = "DocumentStreamFailureToCreate";
    /** Document stream failed to create filter unexpectedly. */
    KnownCollectionConfigurationErrorType["DocumentStreamFailureToCreateFilterUnexpected"] = "DocumentStreamFailureToCreateFilterUnexpected";
    /** Metric duplicate ids. */
    KnownCollectionConfigurationErrorType["MetricDuplicateIds"] = "MetricDuplicateIds";
    /** Metric telemetry type unsupported. */
    KnownCollectionConfigurationErrorType["MetricTelemetryTypeUnsupported"] = "MetricTelemetryTypeUnsupported";
    /** Metric failed to create. */
    KnownCollectionConfigurationErrorType["MetricFailureToCreate"] = "MetricFailureToCreate";
    /** Metric failed to create filter unexpectedly. */
    KnownCollectionConfigurationErrorType["MetricFailureToCreateFilterUnexpected"] = "MetricFailureToCreateFilterUnexpected";
    /** Filter failed to create unexpectedly. */
    KnownCollectionConfigurationErrorType["FilterFailureToCreateUnexpected"] = "FilterFailureToCreateUnexpected";
    /** Collection configuration failed to create unexpectedly. */
    KnownCollectionConfigurationErrorType["CollectionConfigurationFailureToCreateUnexpected"] = "CollectionConfigurationFailureToCreateUnexpected";
})(KnownCollectionConfigurationErrorType || (KnownCollectionConfigurationErrorType = {}));
/** Known values of {@link PredicateType} that the service accepts. */
var KnownPredicateType;
(function (KnownPredicateType) {
    /** Represents an equality predicate. */
    KnownPredicateType["Equal"] = "Equal";
    /** Represents a not-equal predicate. */
    KnownPredicateType["NotEqual"] = "NotEqual";
    /** Represents a less-than predicate. */
    KnownPredicateType["LessThan"] = "LessThan";
    /** Represents a greater-than predicate. */
    KnownPredicateType["GreaterThan"] = "GreaterThan";
    /** Represents a less-than-or-equal predicate. */
    KnownPredicateType["LessThanOrEqual"] = "LessThanOrEqual";
    /** Represents a greater-than-or-equal predicate. */
    KnownPredicateType["GreaterThanOrEqual"] = "GreaterThanOrEqual";
    /** Represents a contains predicate. */
    KnownPredicateType["Contains"] = "Contains";
    /** Represents a does-not-contain predicate. */
    KnownPredicateType["DoesNotContain"] = "DoesNotContain";
})(KnownPredicateType || (KnownPredicateType = {}));
/** Known values of {@link AggregationType} that the service accepts. */
var KnownAggregationType;
(function (KnownAggregationType) {
    /** Average */
    KnownAggregationType["Avg"] = "Avg";
    /** Sum */
    KnownAggregationType["Sum"] = "Sum";
    /** Minimum */
    KnownAggregationType["Min"] = "Min";
    /** Maximum */
    KnownAggregationType["Max"] = "Max";
})(KnownAggregationType || (KnownAggregationType = {}));
/** Known values of {@link TelemetryType} that the service accepts. */
var KnownTelemetryType;
(function (KnownTelemetryType) {
    /** Represents a request telemetry type. */
    KnownTelemetryType["Request"] = "Request";
    /** Represents a dependency telemetry type. */
    KnownTelemetryType["Dependency"] = "Dependency";
    /** Represents an exception telemetry type. */
    KnownTelemetryType["Exception"] = "Exception";
    /** Represents an event telemetry type. */
    KnownTelemetryType["Event"] = "Event";
    /** Represents a metric telemetry type. */
    KnownTelemetryType["Metric"] = "Metric";
    /** Represents a performance counter telemetry type. */
    KnownTelemetryType["PerformanceCounter"] = "PerformanceCounter";
    /** Represents a trace telemetry type. */
    KnownTelemetryType["Trace"] = "Trace";
})(KnownTelemetryType || (KnownTelemetryType = {}));

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const MonitoringDataPoint = {
    type: {
        name: "Composite",
        className: "MonitoringDataPoint",
        modelProperties: {
            version: {
                serializedName: "Version",
                required: true,
                type: {
                    name: "String",
                },
            },
            invariantVersion: {
                serializedName: "InvariantVersion",
                required: true,
                type: {
                    name: "Number",
                },
            },
            instance: {
                serializedName: "Instance",
                required: true,
                type: {
                    name: "String",
                },
            },
            roleName: {
                serializedName: "RoleName",
                required: true,
                type: {
                    name: "String",
                },
            },
            machineName: {
                serializedName: "MachineName",
                required: true,
                type: {
                    name: "String",
                },
            },
            streamId: {
                serializedName: "StreamId",
                required: true,
                type: {
                    name: "String",
                },
            },
            timestamp: {
                serializedName: "Timestamp",
                type: {
                    name: "DateTime",
                },
            },
            transmissionTime: {
                serializedName: "TransmissionTime",
                type: {
                    name: "DateTime",
                },
            },
            isWebApp: {
                serializedName: "IsWebApp",
                required: true,
                type: {
                    name: "Boolean",
                },
            },
            performanceCollectionSupported: {
                serializedName: "PerformanceCollectionSupported",
                required: true,
                type: {
                    name: "Boolean",
                },
            },
            metrics: {
                serializedName: "Metrics",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "MetricPoint",
                        },
                    },
                },
            },
            documents: {
                serializedName: "Documents",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DocumentIngress",
                        },
                    },
                },
            },
            topCpuProcesses: {
                serializedName: "TopCpuProcesses",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ProcessCpuData",
                        },
                    },
                },
            },
            collectionConfigurationErrors: {
                serializedName: "CollectionConfigurationErrors",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "CollectionConfigurationError",
                        },
                    },
                },
            },
        },
    },
};
const MetricPoint = {
    type: {
        name: "Composite",
        className: "MetricPoint",
        modelProperties: {
            name: {
                serializedName: "Name",
                required: true,
                type: {
                    name: "String",
                },
            },
            value: {
                serializedName: "Value",
                required: true,
                type: {
                    name: "Number",
                },
            },
            weight: {
                serializedName: "Weight",
                required: true,
                type: {
                    name: "Number",
                },
            },
        },
    },
};
const DocumentIngress = {
    type: {
        name: "Composite",
        className: "DocumentIngress",
        uberParent: "DocumentIngress",
        polymorphicDiscriminator: {
            serializedName: "DocumentType",
            clientName: "documentType",
        },
        modelProperties: {
            documentType: {
                serializedName: "DocumentType",
                required: true,
                type: {
                    name: "String",
                },
            },
            documentStreamIds: {
                serializedName: "DocumentStreamIds",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String",
                        },
                    },
                },
            },
            properties: {
                serializedName: "Properties",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "KeyValuePairString",
                        },
                    },
                },
            },
        },
    },
};
const KeyValuePairString = {
    type: {
        name: "Composite",
        className: "KeyValuePairString",
        modelProperties: {
            key: {
                serializedName: "key",
                required: true,
                type: {
                    name: "String",
                },
            },
            value: {
                serializedName: "value",
                required: true,
                type: {
                    name: "String",
                },
            },
        },
    },
};
const ProcessCpuData = {
    type: {
        name: "Composite",
        className: "ProcessCpuData",
        modelProperties: {
            processName: {
                serializedName: "ProcessName",
                required: true,
                type: {
                    name: "String",
                },
            },
            cpuPercentage: {
                serializedName: "CpuPercentage",
                required: true,
                type: {
                    name: "Number",
                },
            },
        },
    },
};
const CollectionConfigurationError = {
    type: {
        name: "Composite",
        className: "CollectionConfigurationError",
        modelProperties: {
            collectionConfigurationErrorType: {
                serializedName: "CollectionConfigurationErrorType",
                required: true,
                type: {
                    name: "String",
                },
            },
            message: {
                serializedName: "Message",
                required: true,
                type: {
                    name: "String",
                },
            },
            fullException: {
                serializedName: "FullException",
                required: true,
                type: {
                    name: "String",
                },
            },
            data: {
                serializedName: "Data",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "KeyValuePairString",
                        },
                    },
                },
            },
        },
    },
};
const CollectionConfigurationInfo = {
    type: {
        name: "Composite",
        className: "CollectionConfigurationInfo",
        modelProperties: {
            eTag: {
                serializedName: "ETag",
                required: true,
                type: {
                    name: "String",
                },
            },
            metrics: {
                serializedName: "Metrics",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DerivedMetricInfo",
                        },
                    },
                },
            },
            documentStreams: {
                serializedName: "DocumentStreams",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DocumentStreamInfo",
                        },
                    },
                },
            },
            quotaInfo: {
                serializedName: "QuotaInfo",
                type: {
                    name: "Composite",
                    className: "QuotaConfigurationInfo",
                },
            },
        },
    },
};
const DerivedMetricInfo = {
    type: {
        name: "Composite",
        className: "DerivedMetricInfo",
        modelProperties: {
            id: {
                serializedName: "Id",
                required: true,
                type: {
                    name: "String",
                },
            },
            telemetryType: {
                serializedName: "TelemetryType",
                required: true,
                type: {
                    name: "String",
                },
            },
            filterGroups: {
                serializedName: "FilterGroups",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "FilterConjunctionGroupInfo",
                        },
                    },
                },
            },
            projection: {
                serializedName: "Projection",
                required: true,
                type: {
                    name: "String",
                },
            },
            aggregation: {
                serializedName: "Aggregation",
                required: true,
                type: {
                    name: "String",
                },
            },
            backEndAggregation: {
                serializedName: "BackEndAggregation",
                required: true,
                type: {
                    name: "String",
                },
            },
        },
    },
};
const FilterConjunctionGroupInfo = {
    type: {
        name: "Composite",
        className: "FilterConjunctionGroupInfo",
        modelProperties: {
            filters: {
                serializedName: "Filters",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "FilterInfo",
                        },
                    },
                },
            },
        },
    },
};
const FilterInfo = {
    type: {
        name: "Composite",
        className: "FilterInfo",
        modelProperties: {
            fieldName: {
                serializedName: "FieldName",
                required: true,
                type: {
                    name: "String",
                },
            },
            predicate: {
                serializedName: "Predicate",
                required: true,
                type: {
                    name: "String",
                },
            },
            comparand: {
                serializedName: "Comparand",
                required: true,
                type: {
                    name: "String",
                },
            },
        },
    },
};
const DocumentStreamInfo = {
    type: {
        name: "Composite",
        className: "DocumentStreamInfo",
        modelProperties: {
            id: {
                serializedName: "Id",
                required: true,
                type: {
                    name: "String",
                },
            },
            documentFilterGroups: {
                serializedName: "DocumentFilterGroups",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DocumentFilterConjunctionGroupInfo",
                        },
                    },
                },
            },
        },
    },
};
const DocumentFilterConjunctionGroupInfo = {
    type: {
        name: "Composite",
        className: "DocumentFilterConjunctionGroupInfo",
        modelProperties: {
            telemetryType: {
                serializedName: "TelemetryType",
                required: true,
                type: {
                    name: "String",
                },
            },
            filters: {
                serializedName: "Filters",
                type: {
                    name: "Composite",
                    className: "FilterConjunctionGroupInfo",
                },
            },
        },
    },
};
const QuotaConfigurationInfo = {
    type: {
        name: "Composite",
        className: "QuotaConfigurationInfo",
        modelProperties: {
            initialQuota: {
                serializedName: "InitialQuota",
                type: {
                    name: "Number",
                },
            },
            maxQuota: {
                serializedName: "MaxQuota",
                required: true,
                type: {
                    name: "Number",
                },
            },
            quotaAccrualRatePerSec: {
                serializedName: "QuotaAccrualRatePerSec",
                required: true,
                type: {
                    name: "Number",
                },
            },
        },
    },
};
const ServiceError = {
    type: {
        name: "Composite",
        className: "ServiceError",
        modelProperties: {
            requestId: {
                defaultValue: "00000000-0000-0000-0000-000000000000",
                serializedName: "RequestId",
                required: true,
                type: {
                    name: "String",
                },
            },
            responseDateTime: {
                serializedName: "ResponseDateTime",
                required: true,
                type: {
                    name: "String",
                },
            },
            code: {
                serializedName: "Code",
                required: true,
                type: {
                    name: "String",
                },
            },
            message: {
                serializedName: "Message",
                required: true,
                type: {
                    name: "String",
                },
            },
            exception: {
                serializedName: "Exception",
                required: true,
                type: {
                    name: "String",
                },
            },
        },
    },
};
const Event = {
    serializedName: "Event",
    type: {
        name: "Composite",
        className: "Event",
        uberParent: "DocumentIngress",
        polymorphicDiscriminator: DocumentIngress.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, DocumentIngress.type.modelProperties), { name: {
                constraints: {
                    MaxLength: 512,
                },
                serializedName: "Name",
                type: {
                    name: "String",
                },
            } }),
    },
};
const Exception = {
    serializedName: "Exception",
    type: {
        name: "Composite",
        className: "Exception",
        uberParent: "DocumentIngress",
        polymorphicDiscriminator: DocumentIngress.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, DocumentIngress.type.modelProperties), { exceptionType: {
                constraints: {
                    MaxLength: 1024,
                },
                serializedName: "ExceptionType",
                type: {
                    name: "String",
                },
            }, exceptionMessage: {
                constraints: {
                    MaxLength: 32768,
                },
                serializedName: "ExceptionMessage",
                type: {
                    name: "String",
                },
            } }),
    },
};
const RemoteDependency = {
    serializedName: "RemoteDependency",
    type: {
        name: "Composite",
        className: "RemoteDependency",
        uberParent: "DocumentIngress",
        polymorphicDiscriminator: DocumentIngress.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, DocumentIngress.type.modelProperties), { name: {
                constraints: {
                    MaxLength: 1024,
                },
                serializedName: "Name",
                type: {
                    name: "String",
                },
            }, commandName: {
                constraints: {
                    MaxLength: 2048,
                },
                serializedName: "CommandName",
                type: {
                    name: "String",
                },
            }, resultCode: {
                constraints: {
                    MaxLength: 1024,
                },
                serializedName: "ResultCode",
                type: {
                    name: "String",
                },
            }, duration: {
                serializedName: "Duration",
                type: {
                    name: "String",
                },
            } }),
    },
};
const Request = {
    serializedName: "Request",
    type: {
        name: "Composite",
        className: "Request",
        uberParent: "DocumentIngress",
        polymorphicDiscriminator: DocumentIngress.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, DocumentIngress.type.modelProperties), { name: {
                constraints: {
                    MaxLength: 1024,
                },
                serializedName: "Name",
                type: {
                    name: "String",
                },
            }, url: {
                constraints: {
                    MaxLength: 2048,
                },
                serializedName: "Url",
                type: {
                    name: "String",
                },
            }, responseCode: {
                constraints: {
                    MaxLength: 1024,
                },
                serializedName: "ResponseCode",
                type: {
                    name: "String",
                },
            }, duration: {
                serializedName: "Duration",
                type: {
                    name: "String",
                },
            } }),
    },
};
const Trace = {
    serializedName: "Trace",
    type: {
        name: "Composite",
        className: "Trace",
        uberParent: "DocumentIngress",
        polymorphicDiscriminator: DocumentIngress.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, DocumentIngress.type.modelProperties), { message: {
                constraints: {
                    MaxLength: 32768,
                },
                serializedName: "Message",
                type: {
                    name: "String",
                },
            } }),
    },
};
const QuickpulseClientIsSubscribedHeaders = {
    type: {
        name: "Composite",
        className: "QuickpulseClientIsSubscribedHeaders",
        modelProperties: {
            xMsQpsSubscribed: {
                serializedName: "x-ms-qps-subscribed",
                type: {
                    name: "String",
                },
            },
            xMsQpsConfigurationEtag: {
                serializedName: "x-ms-qps-configuration-etag",
                type: {
                    name: "String",
                },
            },
            xMsQpsServicePollingIntervalHint: {
                serializedName: "x-ms-qps-service-polling-interval-hint",
                type: {
                    name: "String",
                },
            },
            xMsQpsServiceEndpointRedirectV2: {
                serializedName: "x-ms-qps-service-endpoint-redirect-v2",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const QuickpulseClientPublishHeaders = {
    type: {
        name: "Composite",
        className: "QuickpulseClientPublishHeaders",
        modelProperties: {
            xMsQpsSubscribed: {
                serializedName: "x-ms-qps-subscribed",
                type: {
                    name: "String",
                },
            },
            xMsQpsConfigurationEtag: {
                serializedName: "x-ms-qps-configuration-etag",
                type: {
                    name: "String",
                },
            },
        },
    },
};
let discriminators = {
    DocumentIngress: DocumentIngress,
    "DocumentIngress.Event": Event,
    "DocumentIngress.Exception": Exception,
    "DocumentIngress.RemoteDependency": RemoteDependency,
    "DocumentIngress.Request": Request,
    "DocumentIngress.Trace": Trace,
};

var Mappers = /*#__PURE__*/Object.freeze({
    __proto__: null,
    CollectionConfigurationError: CollectionConfigurationError,
    CollectionConfigurationInfo: CollectionConfigurationInfo,
    DerivedMetricInfo: DerivedMetricInfo,
    DocumentFilterConjunctionGroupInfo: DocumentFilterConjunctionGroupInfo,
    DocumentIngress: DocumentIngress,
    DocumentStreamInfo: DocumentStreamInfo,
    Event: Event,
    Exception: Exception,
    FilterConjunctionGroupInfo: FilterConjunctionGroupInfo,
    FilterInfo: FilterInfo,
    KeyValuePairString: KeyValuePairString,
    MetricPoint: MetricPoint,
    MonitoringDataPoint: MonitoringDataPoint,
    ProcessCpuData: ProcessCpuData,
    QuickpulseClientIsSubscribedHeaders: QuickpulseClientIsSubscribedHeaders,
    QuickpulseClientPublishHeaders: QuickpulseClientPublishHeaders,
    QuotaConfigurationInfo: QuotaConfigurationInfo,
    RemoteDependency: RemoteDependency,
    Request: Request,
    ServiceError: ServiceError,
    Trace: Trace,
    discriminators: discriminators
});

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const contentType = {
    parameterPath: ["options", "contentType"],
    mapper: {
        defaultValue: "application/json",
        isConstant: true,
        serializedName: "Content-Type",
        type: {
            name: "String",
        },
    },
};
const monitoringDataPoint = {
    parameterPath: ["options", "monitoringDataPoint"],
    mapper: MonitoringDataPoint,
};
const accept = {
    parameterPath: "accept",
    mapper: {
        defaultValue: "application/json",
        isConstant: true,
        serializedName: "Accept",
        type: {
            name: "String",
        },
    },
};
const endpoint = {
    parameterPath: "endpoint",
    mapper: {
        serializedName: "endpoint",
        required: true,
        type: {
            name: "String",
        },
    },
};
const apiVersion = {
    parameterPath: "apiVersion",
    mapper: {
        defaultValue: "2024-04-01-preview",
        isConstant: true,
        serializedName: "api-version",
        type: {
            name: "String",
        },
    },
};
const ikey = {
    parameterPath: "ikey",
    mapper: {
        serializedName: "ikey",
        required: true,
        type: {
            name: "String",
        },
    },
};
const transmissionTime = {
    parameterPath: ["options", "transmissionTime"],
    mapper: {
        serializedName: "x-ms-qps-transmission-time",
        type: {
            name: "Number",
        },
    },
};
const machineName = {
    parameterPath: ["options", "machineName"],
    mapper: {
        serializedName: "x-ms-qps-machine-name",
        type: {
            name: "String",
        },
    },
};
const instanceName = {
    parameterPath: ["options", "instanceName"],
    mapper: {
        serializedName: "x-ms-qps-instance-name",
        type: {
            name: "String",
        },
    },
};
const streamId = {
    parameterPath: ["options", "streamId"],
    mapper: {
        serializedName: "x-ms-qps-stream-id",
        type: {
            name: "String",
        },
    },
};
const roleName = {
    parameterPath: ["options", "roleName"],
    mapper: {
        serializedName: "x-ms-qps-role-name",
        type: {
            name: "String",
        },
    },
};
const invariantVersion = {
    parameterPath: ["options", "invariantVersion"],
    mapper: {
        serializedName: "x-ms-qps-invariant-version",
        type: {
            name: "String",
        },
    },
};
const configurationEtag = {
    parameterPath: ["options", "configurationEtag"],
    mapper: {
        serializedName: "x-ms-qps-configuration-etag",
        type: {
            name: "String",
        },
    },
};
const monitoringDataPoints = {
    parameterPath: ["options", "monitoringDataPoints"],
    mapper: {
        serializedName: "monitoringDataPoints",
        type: {
            name: "Sequence",
            element: {
                type: {
                    name: "Composite",
                    className: "MonitoringDataPoint",
                },
            },
        },
    },
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
class QuickpulseClient extends coreClient__namespace.ServiceClient {
    /**
     * Initializes a new instance of the QuickpulseClient class.
     * @param options The parameter options
     */
    constructor(options) {
        var _a, _b;
        // Initializing default values for options
        if (!options) {
            options = {};
        }
        const defaults = {
            requestContentType: "application/json; charset=utf-8",
        };
        const packageDetails = `azsdk-js-monitor-opentelemetry/1.0.0-beta.0`;
        const userAgentPrefix = options.userAgentOptions && options.userAgentOptions.userAgentPrefix
            ? `${options.userAgentOptions.userAgentPrefix} ${packageDetails}`
            : `${packageDetails}`;
        const optionsWithDefaults = Object.assign(Object.assign(Object.assign({}, defaults), options), { userAgentOptions: {
                userAgentPrefix,
            }, endpoint: (_b = (_a = options.endpoint) !== null && _a !== void 0 ? _a : options.baseUri) !== null && _b !== void 0 ? _b : "{endpoint}" });
        super(optionsWithDefaults);
        // Assigning values to Constant parameters
        this.apiVersion = options.apiVersion || "2024-04-01-preview";
        this.addCustomApiVersionPolicy(options.apiVersion);
    }
    /** A function that adds a policy that sets the api-version (or equivalent) to reflect the library version. */
    addCustomApiVersionPolicy(apiVersion) {
        if (!apiVersion) {
            return;
        }
        const apiVersionPolicy = {
            name: "CustomApiVersionPolicy",
            async sendRequest(request, next) {
                const param = request.url.split("?");
                if (param.length > 1) {
                    const newParams = param[1].split("&").map((item) => {
                        if (item.indexOf("api-version") > -1) {
                            return "api-version=" + apiVersion;
                        }
                        else {
                            return item;
                        }
                    });
                    request.url = param[0] + "?" + newParams.join("&");
                }
                return next(request);
            },
        };
        this.pipeline.addPolicy(apiVersionPolicy);
    }
    /**
     * Determine whether there is any subscription to the metrics and documents.
     * @param endpoint The endpoint of the Live Metrics service.
     * @param ikey The instrumentation key of the target Application Insights component for which the
     *             client checks whether there's any subscription to it.
     * @param options The options parameters.
     */
    isSubscribed(endpoint, ikey, options) {
        return this.sendOperationRequest({ endpoint, ikey, options }, isSubscribedOperationSpec);
    }
    /**
     * Publish live metrics to the Live Metrics service when there is an active subscription to the
     * metrics.
     * @param endpoint The endpoint of the Live Metrics service.
     * @param ikey The instrumentation key of the target Application Insights component for which the
     *             client checks whether there's any subscription to it.
     * @param options The options parameters.
     */
    publish(endpoint, ikey, options) {
        return this.sendOperationRequest({ endpoint, ikey, options }, publishOperationSpec);
    }
}
// Operation Specifications
const serializer = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const isSubscribedOperationSpec = {
    path: "/QuickPulseService.svc/ping",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: CollectionConfigurationInfo,
            headersMapper: QuickpulseClientIsSubscribedHeaders,
        },
        default: {
            bodyMapper: ServiceError,
        },
    },
    requestBody: monitoringDataPoint,
    queryParameters: [apiVersion, ikey],
    urlParameters: [endpoint],
    headerParameters: [
        contentType,
        accept,
        transmissionTime,
        machineName,
        instanceName,
        streamId,
        roleName,
        invariantVersion,
        configurationEtag,
    ],
    mediaType: "json",
    serializer,
};
const publishOperationSpec = {
    path: "/QuickPulseService.svc/post",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: CollectionConfigurationInfo,
            headersMapper: QuickpulseClientPublishHeaders,
        },
        default: {
            bodyMapper: ServiceError,
        },
    },
    requestBody: monitoringDataPoints,
    queryParameters: [apiVersion, ikey],
    urlParameters: [endpoint],
    headerParameters: [
        contentType,
        accept,
        transmissionTime,
        configurationEtag,
    ],
    mediaType: "json",
    serializer,
};

/**
 * Statsbeat Features Mapping
 * @internal
 */
const StatsbeatFeaturesMap = new Map([
    ["diskRetry", 1],
    ["aadHandling", 2],
    ["browserSdkLoader", 4],
    ["distro", 8],
    ["liveMetrics", 16],
    ["shim", 32],
]);
const AZURE_MONITOR_OPENTELEMETRY_VERSION = "1.9.0";
const AZURE_MONITOR_STATSBEAT_FEATURES = "AZURE_MONITOR_STATSBEAT_FEATURES";
const AZURE_MONITOR_PREFIX = "AZURE_MONITOR_PREFIX";
const AZURE_MONITOR_AUTO_ATTACH = "AZURE_MONITOR_AUTO_ATTACH";
var AttachTypePrefix;
(function (AttachTypePrefix) {
    AttachTypePrefix["INTEGRATED_AUTO"] = "i";
    AttachTypePrefix["MANUAL"] = "m";
})(AttachTypePrefix || (AttachTypePrefix = {}));
/**
 * Default Browser SDK Loader Source
 * @internal
 */
const BROWSER_SDK_LOADER_DEFAULT_SOURCE = "https://js.monitor.azure.com/scripts/b/ai";
/**
 * Default Breeze endpoint.
 * @internal
 */
const DEFAULT_BREEZE_ENDPOINT = "https://dc.services.visualstudio.com";
/**
 * Default Live Metrics endpoint.
 * @internal
 */
const DEFAULT_LIVEMETRICS_ENDPOINT = "https://global.livediagnostics.monitor.azure.com";
/**
 * Internal attribute name for sample rate
 * @internal
 */
const AzureMonitorSampleRate = "microsoft.sample_rate";
var StatsbeatFeature;
(function (StatsbeatFeature) {
    StatsbeatFeature[StatsbeatFeature["NONE"] = 0] = "NONE";
    StatsbeatFeature[StatsbeatFeature["DISK_RETRY"] = 1] = "DISK_RETRY";
    StatsbeatFeature[StatsbeatFeature["AAD_HANDLING"] = 2] = "AAD_HANDLING";
    StatsbeatFeature[StatsbeatFeature["BROWSER_SDK_LOADER"] = 4] = "BROWSER_SDK_LOADER";
    StatsbeatFeature[StatsbeatFeature["DISTRO"] = 8] = "DISTRO";
    StatsbeatFeature[StatsbeatFeature["LIVE_METRICS"] = 16] = "LIVE_METRICS";
    StatsbeatFeature[StatsbeatFeature["SHIM"] = 32] = "SHIM";
})(StatsbeatFeature || (StatsbeatFeature = {}));
var StatsbeatInstrumentation;
(function (StatsbeatInstrumentation) {
    /** Azure Monitor Supported Instrumentations */
    StatsbeatInstrumentation[StatsbeatInstrumentation["NONE"] = 0] = "NONE";
    StatsbeatInstrumentation[StatsbeatInstrumentation["AZURE_CORE_TRACING"] = 1] = "AZURE_CORE_TRACING";
    StatsbeatInstrumentation[StatsbeatInstrumentation["MONGODB"] = 2] = "MONGODB";
    StatsbeatInstrumentation[StatsbeatInstrumentation["MYSQL"] = 4] = "MYSQL";
    StatsbeatInstrumentation[StatsbeatInstrumentation["REDIS"] = 8] = "REDIS";
    StatsbeatInstrumentation[StatsbeatInstrumentation["POSTGRES"] = 16] = "POSTGRES";
    StatsbeatInstrumentation[StatsbeatInstrumentation["BUNYAN"] = 32] = "BUNYAN";
    StatsbeatInstrumentation[StatsbeatInstrumentation["WINSTON"] = 64] = "WINSTON";
    /** OpenTelemetry Supported Instrumentations */
    // Console instrumentation is not supported here - occupies 128
    StatsbeatInstrumentation[StatsbeatInstrumentation["CUCUMBER"] = 256] = "CUCUMBER";
    StatsbeatInstrumentation[StatsbeatInstrumentation["DATALOADER"] = 512] = "DATALOADER";
    StatsbeatInstrumentation[StatsbeatInstrumentation["FS"] = 1024] = "FS";
    StatsbeatInstrumentation[StatsbeatInstrumentation["LRU_MEMOIZER"] = 2048] = "LRU_MEMOIZER";
    StatsbeatInstrumentation[StatsbeatInstrumentation["MONGOOSE"] = 4096] = "MONGOOSE";
    StatsbeatInstrumentation[StatsbeatInstrumentation["RUNTIME_NODE"] = 8192] = "RUNTIME_NODE";
    StatsbeatInstrumentation[StatsbeatInstrumentation["SOCKET_IO"] = 16384] = "SOCKET_IO";
    StatsbeatInstrumentation[StatsbeatInstrumentation["TEDIOUS"] = 32768] = "TEDIOUS";
    StatsbeatInstrumentation[StatsbeatInstrumentation["UNDICI"] = 65536] = "UNDICI";
    StatsbeatInstrumentation[StatsbeatInstrumentation["CASSANDRA"] = 131072] = "CASSANDRA";
    StatsbeatInstrumentation[StatsbeatInstrumentation["CONNECT"] = 262144] = "CONNECT";
    StatsbeatInstrumentation[StatsbeatInstrumentation["DNS"] = 524288] = "DNS";
    StatsbeatInstrumentation[StatsbeatInstrumentation["EXPRESS"] = 1048576] = "EXPRESS";
    StatsbeatInstrumentation[StatsbeatInstrumentation["FASTIFY"] = 2097152] = "FASTIFY";
    StatsbeatInstrumentation[StatsbeatInstrumentation["GENERIC_POOL"] = 4194304] = "GENERIC_POOL";
    StatsbeatInstrumentation[StatsbeatInstrumentation["GRAPHQL"] = 8388608] = "GRAPHQL";
    StatsbeatInstrumentation[StatsbeatInstrumentation["HAPI"] = 16777216] = "HAPI";
    StatsbeatInstrumentation[StatsbeatInstrumentation["IOREDIS"] = 33554432] = "IOREDIS";
    StatsbeatInstrumentation[StatsbeatInstrumentation["KNEX"] = 67108864] = "KNEX";
    StatsbeatInstrumentation[StatsbeatInstrumentation["KOA"] = 134217728] = "KOA";
    StatsbeatInstrumentation[StatsbeatInstrumentation["MEMCACHED"] = 268435456] = "MEMCACHED";
    StatsbeatInstrumentation[StatsbeatInstrumentation["MYSQL2"] = 536870912] = "MYSQL2";
    StatsbeatInstrumentation[StatsbeatInstrumentation["NESTJS_CORE"] = 1073741824] = "NESTJS_CORE";
    StatsbeatInstrumentation[StatsbeatInstrumentation["NET"] = 2147483648] = "NET";
    StatsbeatInstrumentation[StatsbeatInstrumentation["PINO"] = 4294967296] = "PINO";
    StatsbeatInstrumentation[StatsbeatInstrumentation["RESTIFY"] = 8589934592] = "RESTIFY";
    StatsbeatInstrumentation[StatsbeatInstrumentation["ROUTER"] = 17179869184] = "ROUTER";
    StatsbeatInstrumentation[StatsbeatInstrumentation["AMQPLIB"] = 34359738368] = "AMQPLIB";
})(StatsbeatInstrumentation || (StatsbeatInstrumentation = {}));
/**
 * Statsbeat Instrumentation Mapping
 * @internal
 */
const StatsbeatInstrumentationMap = new Map([
    ["@opentelemetry/instrumentation-amqplib", StatsbeatInstrumentation.AMQPLIB],
    ["@opentelemetry/instrumentation-cucumber", StatsbeatInstrumentation.CUCUMBER],
    ["@opentelemetry/instrumentation-dataloader", StatsbeatInstrumentation.DATALOADER],
    ["@opentelemetry/instrumentation-fs", StatsbeatInstrumentation.FS],
    ["@opentelemetry/instrumentation-lru-memoizer", StatsbeatInstrumentation.LRU_MEMOIZER],
    ["@opentelemetry/instrumentation-mongoose", StatsbeatInstrumentation.MONGOOSE],
    ["@opentelemetry/instrumentation-runtime-node", StatsbeatInstrumentation.RUNTIME_NODE],
    ["@opentelemetry/instrumentation-socket.io", StatsbeatInstrumentation.SOCKET_IO],
    ["@opentelemetry/instrumentation-tedious", StatsbeatInstrumentation.TEDIOUS],
    ["@opentelemetry/instrumentation-undici", StatsbeatInstrumentation.UNDICI],
    ["@opentelemetry/instrumentation-cassandra-driver", StatsbeatInstrumentation.CASSANDRA],
    ["@opentelemetry/instrumentation-connect", StatsbeatInstrumentation.CONNECT],
    ["@opentelemetry/instrumentation-dns", StatsbeatInstrumentation.DNS],
    ["@opentelemetry/instrumentation-express", StatsbeatInstrumentation.EXPRESS],
    ["@opentelemetry/instrumentation-fastify", StatsbeatInstrumentation.FASTIFY],
    ["@opentelemetry/instrumentation-generic-pool", StatsbeatInstrumentation.GENERIC_POOL],
    ["@opentelemetry/instrumentation-graphql", StatsbeatInstrumentation.GRAPHQL],
    ["@opentelemetry/instrumentation-hapi", StatsbeatInstrumentation.HAPI],
    ["@opentelemetry/instrumentation-ioredis", StatsbeatInstrumentation.IOREDIS],
    ["@opentelemetry/instrumentation-knex", StatsbeatInstrumentation.KNEX],
    ["@opentelemetry/instrumentation-koa", StatsbeatInstrumentation.KOA],
    ["@opentelemetry/instrumentation-memcached", StatsbeatInstrumentation.MEMCACHED],
    ["@opentelemetry/instrumentation-mysql2", StatsbeatInstrumentation.MYSQL2],
    ["@opentelemetry/instrumentation-nestjs-core", StatsbeatInstrumentation.NESTJS_CORE],
    ["@opentelemetry/instrumentation-net", StatsbeatInstrumentation.NET],
    ["@opentelemetry/instrumentation-pino", StatsbeatInstrumentation.PINO],
    ["@opentelemetry/instrumentation-restify", StatsbeatInstrumentation.RESTIFY],
    ["@opentelemetry/instrumentation-router", StatsbeatInstrumentation.ROUTER],
]);

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
var QuickPulseOpenTelemetryMetricNames;
(function (QuickPulseOpenTelemetryMetricNames) {
    QuickPulseOpenTelemetryMetricNames["PHYSICAL_BYTES"] = "azureMonitor.physicalBytes";
    QuickPulseOpenTelemetryMetricNames["PROCESSOR_TIME_NORMALIZED"] = "azureMonitor.percentProcessorTimeNormalized";
    QuickPulseOpenTelemetryMetricNames["REQUEST_RATE"] = "azureMonitor.requestsSec";
    QuickPulseOpenTelemetryMetricNames["REQUEST_FAILURE_RATE"] = "azureMonitor.requestsFailedSec";
    QuickPulseOpenTelemetryMetricNames["REQUEST_DURATION"] = "azureMonitor.requestDuration";
    QuickPulseOpenTelemetryMetricNames["DEPENDENCY_RATE"] = "azureMonitor.dependencyCallsSec";
    QuickPulseOpenTelemetryMetricNames["DEPENDENCY_FAILURE_RATE"] = "azureMonitor.dependencyCallsFailedSec";
    QuickPulseOpenTelemetryMetricNames["DEPENDENCY_DURATION"] = "azureMonitor.dependencyCallDuration";
    QuickPulseOpenTelemetryMetricNames["EXCEPTION_RATE"] = "azureMonitor.exceptionsSec";
})(QuickPulseOpenTelemetryMetricNames || (QuickPulseOpenTelemetryMetricNames = {}));
var QuickPulseMetricNames;
(function (QuickPulseMetricNames) {
    // Memory (old)
    QuickPulseMetricNames["COMMITTED_BYTES"] = "\\Memory\\Committed Bytes";
    // Memory (new - current process)
    QuickPulseMetricNames["PHYSICAL_BYTES"] = "\\Process\\Physical Bytes";
    // CPU (old)
    QuickPulseMetricNames["PROCESSOR_TIME"] = "\\Processor(_Total)\\% Processor Time";
    // CPU (new - current process)
    QuickPulseMetricNames["PROCESSOR_TIME_NORMALIZED"] = "\\% Process\\Processor Time Normalized";
    // Request
    QuickPulseMetricNames["REQUEST_RATE"] = "\\ApplicationInsights\\Requests/Sec";
    QuickPulseMetricNames["REQUEST_FAILURE_RATE"] = "\\ApplicationInsights\\Requests Failed/Sec";
    QuickPulseMetricNames["REQUEST_DURATION"] = "\\ApplicationInsights\\Request Duration";
    // Dependency
    QuickPulseMetricNames["DEPENDENCY_RATE"] = "\\ApplicationInsights\\Dependency Calls/Sec";
    QuickPulseMetricNames["DEPENDENCY_FAILURE_RATE"] = "\\ApplicationInsights\\Dependency Calls Failed/Sec";
    QuickPulseMetricNames["DEPENDENCY_DURATION"] = "\\ApplicationInsights\\Dependency Call Duration";
    // Exception
    QuickPulseMetricNames["EXCEPTION_RATE"] = "\\ApplicationInsights\\Exceptions/Sec";
})(QuickPulseMetricNames || (QuickPulseMetricNames = {}));
// copied from exporter constants & added a few more
var DependencyTypes;
(function (DependencyTypes) {
    DependencyTypes["InProc"] = "InProc";
    DependencyTypes["QueueMessage"] = "Queue Message";
    DependencyTypes["Sql"] = "SQL";
    DependencyTypes["Http"] = "Http";
    DependencyTypes["Grpc"] = "GRPC";
    DependencyTypes["Wcf"] = "WCF Service";
    DependencyTypes["mysql"] = "mysql";
    DependencyTypes["postgresql"] = "postgresql";
    DependencyTypes["mongodb"] = "mongodb";
    DependencyTypes["redis"] = "redis";
})(DependencyTypes || (DependencyTypes = {}));
var KnownRequestColumns;
(function (KnownRequestColumns) {
    KnownRequestColumns["Url"] = "Url";
    KnownRequestColumns["Duration"] = "Duration";
    KnownRequestColumns["ResponseCode"] = "ResponseCode";
    KnownRequestColumns["Success"] = "Success";
    KnownRequestColumns["Name"] = "Name";
})(KnownRequestColumns || (KnownRequestColumns = {}));
var KnownDependencyColumns;
(function (KnownDependencyColumns) {
    KnownDependencyColumns["Target"] = "Target";
    KnownDependencyColumns["Duration"] = "Duration";
    KnownDependencyColumns["Success"] = "Success";
    KnownDependencyColumns["Name"] = "Name";
    KnownDependencyColumns["ResultCode"] = "ResultCode";
    KnownDependencyColumns["Type"] = "Type";
    KnownDependencyColumns["Data"] = "Data";
})(KnownDependencyColumns || (KnownDependencyColumns = {}));
/**
 * Legacy HTTP semantic convention values
 * @internal
 */
const legacySemanticValues = [
    semanticConventions.SEMATTRS_NET_PEER_IP,
    semanticConventions.SEMATTRS_NET_PEER_NAME,
    semanticConventions.SEMATTRS_PEER_SERVICE,
    semanticConventions.SEMATTRS_HTTP_METHOD,
    semanticConventions.SEMATTRS_HTTP_URL,
    semanticConventions.SEMATTRS_HTTP_STATUS_CODE,
    semanticConventions.SEMATTRS_HTTP_ROUTE,
    semanticConventions.SEMATTRS_HTTP_HOST,
    semanticConventions.SEMATTRS_DB_SYSTEM,
    semanticConventions.SEMATTRS_DB_STATEMENT,
    semanticConventions.SEMATTRS_DB_OPERATION,
    semanticConventions.SEMATTRS_DB_NAME,
    semanticConventions.SEMATTRS_RPC_SYSTEM,
    semanticConventions.SEMATTRS_RPC_GRPC_STATUS_CODE,
    semanticConventions.SEMATTRS_EXCEPTION_TYPE,
    semanticConventions.SEMATTRS_EXCEPTION_MESSAGE,
    semanticConventions.SEMATTRS_EXCEPTION_STACKTRACE,
];
/**
 * HTTP semantic convention values
 * @internal
 */
const httpSemanticValues = [
    semanticConventions.ATTR_CLIENT_ADDRESS,
    semanticConventions.ATTR_CLIENT_PORT,
    semanticConventions.ATTR_SERVER_ADDRESS,
    semanticConventions.ATTR_SERVER_PORT,
    semanticConventions.ATTR_URL_FULL,
    semanticConventions.ATTR_URL_PATH,
    semanticConventions.ATTR_URL_QUERY,
    semanticConventions.ATTR_URL_SCHEME,
    semanticConventions.ATTR_URL_PATH,
    semanticConventions.ATTR_ERROR_TYPE,
    semanticConventions.ATTR_NETWORK_LOCAL_ADDRESS,
    semanticConventions.ATTR_NETWORK_LOCAL_PORT,
    semanticConventions.ATTR_NETWORK_PROTOCOL_NAME,
    semanticConventions.ATTR_NETWORK_PEER_ADDRESS,
    semanticConventions.ATTR_NETWORK_PEER_PORT,
    semanticConventions.ATTR_NETWORK_PROTOCOL_VERSION,
    semanticConventions.ATTR_NETWORK_TRANSPORT,
    semanticConventions.ATTR_USER_AGENT_ORIGINAL,
    semanticConventions.ATTR_HTTP_REQUEST_METHOD,
    semanticConventions.ATTR_HTTP_RESPONSE_STATUS_CODE,
];

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/** Get the internal SDK version */
function getSdkVersion() {
    var _a;
    const { nodeVersion } = process.versions;
    const opentelemetryVersion = core.SDK_INFO[semanticConventions.SEMRESATTRS_TELEMETRY_SDK_VERSION];
    const version = `ext${AZURE_MONITOR_OPENTELEMETRY_VERSION}`;
    const internalSdkVersion = `${(_a = process.env[AZURE_MONITOR_PREFIX]) !== null && _a !== void 0 ? _a : ""}node${nodeVersion}:otel${opentelemetryVersion}:${version}`;
    return internalSdkVersion;
}
// eslint-disable-next-line tsdoc/syntax
/** Set the version prefix to a string in the format "{ResourceProvider}{OS}m_ */
function setSdkPrefix() {
    if (!process.env[AZURE_MONITOR_PREFIX]) {
        const prefixAttachType = process.env[AZURE_MONITOR_AUTO_ATTACH] === "true"
            ? AttachTypePrefix.INTEGRATED_AUTO
            : AttachTypePrefix.MANUAL;
        process.env[AZURE_MONITOR_PREFIX] =
            `${getResourceProvider()}${getOsPrefix()}${prefixAttachType}_`;
    }
}
function resourceMetricsToQuickpulseDataPoint(metrics, baseMonitoringDataPoint, documents, errors, derivedMetricValues) {
    const metricPoints = [];
    metrics.scopeMetrics.forEach((scopeMetric) => {
        scopeMetric.metrics.forEach((metric) => {
            metric.dataPoints.forEach((dataPoint) => {
                const metricPoint = {
                    weight: 1,
                    name: "",
                    value: 0,
                };
                // Update name to expected value in Quickpulse, needed because those names are invalid in OTel
                switch (metric.descriptor.name) {
                    case QuickPulseOpenTelemetryMetricNames.PHYSICAL_BYTES:
                        metricPoint.name = QuickPulseMetricNames.PHYSICAL_BYTES;
                        break;
                    case QuickPulseOpenTelemetryMetricNames.DEPENDENCY_DURATION:
                        metricPoint.name = QuickPulseMetricNames.DEPENDENCY_DURATION;
                        break;
                    case QuickPulseOpenTelemetryMetricNames.DEPENDENCY_FAILURE_RATE:
                        metricPoint.name = QuickPulseMetricNames.DEPENDENCY_FAILURE_RATE;
                        break;
                    case QuickPulseOpenTelemetryMetricNames.DEPENDENCY_RATE:
                        metricPoint.name = QuickPulseMetricNames.DEPENDENCY_RATE;
                        break;
                    case QuickPulseOpenTelemetryMetricNames.EXCEPTION_RATE:
                        metricPoint.name = QuickPulseMetricNames.EXCEPTION_RATE;
                        break;
                    case QuickPulseOpenTelemetryMetricNames.PROCESSOR_TIME_NORMALIZED:
                        metricPoint.name = QuickPulseMetricNames.PROCESSOR_TIME_NORMALIZED;
                        break;
                    case QuickPulseOpenTelemetryMetricNames.REQUEST_DURATION:
                        metricPoint.name = QuickPulseMetricNames.REQUEST_DURATION;
                        break;
                    case QuickPulseOpenTelemetryMetricNames.REQUEST_FAILURE_RATE:
                        metricPoint.name = QuickPulseMetricNames.REQUEST_FAILURE_RATE;
                        break;
                    case QuickPulseOpenTelemetryMetricNames.REQUEST_RATE:
                        metricPoint.name = QuickPulseMetricNames.REQUEST_RATE;
                        break;
                    default:
                        metricPoint.name = metric.descriptor.name;
                }
                if (metric.dataPointType === sdkMetrics.DataPointType.SUM ||
                    metric.dataPointType === sdkMetrics.DataPointType.GAUGE) {
                    metricPoint.value = dataPoint.value;
                }
                else {
                    metricPoint.value = dataPoint.value.sum || 0;
                }
                metricPoints.push(metricPoint);
                // TODO: remove the metric points with the old metric names after
                // UI side has done their changes to support the new names.
                if (metricPoint.name === QuickPulseMetricNames.PHYSICAL_BYTES ||
                    metricPoint.name === QuickPulseMetricNames.PROCESSOR_TIME_NORMALIZED) {
                    const oldMetricPoint = {
                        weight: 1,
                        name: metricPoint.name === QuickPulseMetricNames.PHYSICAL_BYTES
                            ? QuickPulseMetricNames.COMMITTED_BYTES
                            : QuickPulseMetricNames.PROCESSOR_TIME,
                        value: dataPoint.value,
                    };
                    metricPoints.push(oldMetricPoint);
                }
            });
        });
    });
    derivedMetricValues.forEach((value, id) => {
        const metricPoint = {
            weight: 1,
            name: id,
            value: value,
        };
        metricPoints.push(metricPoint);
    });
    const quickpulseDataPoint = Object.assign(Object.assign({}, baseMonitoringDataPoint), { timestamp: new Date(), metrics: metricPoints, documents: documents, collectionConfigurationErrors: errors });
    return [quickpulseDataPoint];
}
function getIso8601Duration(milliseconds) {
    const seconds = milliseconds / 1000;
    return `PT${seconds}S`;
}
function getSpanData(span) {
    if (span.kind === api.SpanKind.SERVER || span.kind === api.SpanKind.CONSUMER) {
        // request
        return getRequestData(span);
    }
    else {
        // dependency
        return getDependencyData(span);
    }
}
function getSpanExceptionColumns(eventAttributes, spanAttributes) {
    const exceptionData = {
        Message: eventAttributes[semanticConventions.SEMATTRS_EXCEPTION_MESSAGE],
        StackTrace: eventAttributes[semanticConventions.SEMATTRS_EXCEPTION_STACKTRACE],
        CustomDimensions: createCustomDimsFromAttributes(spanAttributes),
    };
    return exceptionData;
}
// A slightly modified version of createRequestData from spanUtils in exporter
function getRequestData(span) {
    const requestData = {
        Url: "",
        Duration: core.hrTimeToMilliseconds(span.duration),
        ResponseCode: 0,
        Success: false,
        Name: span.name || "",
        CustomDimensions: createCustomDimsFromAttributes(span.attributes),
    };
    const httpMethod = getHttpMethod(span.attributes);
    const grpcStatusCode = span.attributes[semanticConventions.SEMATTRS_RPC_GRPC_STATUS_CODE];
    if (httpMethod) {
        requestData.Url = getUrl(span.attributes);
        if (URL.canParse(requestData.Url)) {
            const urlObj = new URL(requestData.Url);
            requestData.Name = `${httpMethod} ${urlObj.pathname}`;
        }
        else {
            Logger.getInstance().info("Request data sent to live metrics has no valid URL field.");
        }
        const httpStatusCode = getHttpStatusCode(span.attributes);
        if (httpStatusCode) {
            requestData.ResponseCode = Number(httpStatusCode);
        }
    }
    else if (grpcStatusCode) {
        requestData.ResponseCode = Number(grpcStatusCode);
    }
    requestData.Success = span.status.code !== api.SpanStatusCode.ERROR && requestData.ResponseCode < 400;
    return requestData;
}
// A slightly modified version of createDependencyData from spanUtils in exporter
function getDependencyData(span) {
    const dependencyData = {
        Target: "",
        Duration: core.hrTimeToMilliseconds(span.duration),
        Success: span.status.code !== api.SpanStatusCode.ERROR,
        Name: span.name,
        ResultCode: 0,
        Type: "",
        Data: "",
        CustomDimensions: createCustomDimsFromAttributes(span.attributes),
    };
    if (span.kind === api.SpanKind.PRODUCER) {
        dependencyData.Type = DependencyTypes.QueueMessage;
    }
    if (span.kind === api.SpanKind.INTERNAL && span.parentSpanId) {
        dependencyData.Type = DependencyTypes.InProc;
    }
    const httpMethod = getHttpMethod(span.attributes);
    const dbSystem = span.attributes[semanticConventions.SEMATTRS_DB_SYSTEM];
    const rpcSystem = span.attributes[semanticConventions.SEMATTRS_RPC_SYSTEM];
    // HTTP Dependency
    if (httpMethod) {
        const httpUrl = getHttpUrl(span.attributes);
        if (httpUrl) {
            if (URL.canParse(String(httpUrl))) {
                const dependencyUrl = new URL(String(httpUrl));
                dependencyData.Name = `${httpMethod} ${dependencyUrl.pathname}`;
            }
            else {
                Logger.getInstance().info("Dependency data sent to live metrics has no valid URL field.");
            }
        }
        dependencyData.Type = DependencyTypes.Http;
        dependencyData.Data = getUrl(span.attributes);
        const httpStatusCode = getHttpStatusCode(span.attributes);
        if (httpStatusCode) {
            dependencyData.ResultCode = Number(httpStatusCode);
        }
        let target = getDependencyTarget(span.attributes);
        if (target) {
            try {
                // Remove default port
                const portRegex = new RegExp(/(https?)(:\/\/.*)(:\d+)(\S*)/);
                const res = portRegex.exec(target);
                if (res !== null) {
                    const protocol = res[1];
                    const port = res[3];
                    if ((protocol === "https" && port === ":443") ||
                        (protocol === "http" && port === ":80")) {
                        // Drop port
                        target = res[1] + res[2] + res[4];
                    }
                }
            }
            catch (ex) {
                /* no-op */
            }
            dependencyData.Target = `${target}`;
        }
    }
    // DB Dependency
    else if (dbSystem) {
        // TODO: Remove special logic when Azure UX supports OpenTelemetry dbSystem
        if (String(dbSystem) === semanticConventions.DBSYSTEMVALUES_MYSQL) {
            dependencyData.Type = DependencyTypes.mysql;
        }
        else if (String(dbSystem) === semanticConventions.DBSYSTEMVALUES_POSTGRESQL) {
            dependencyData.Type = DependencyTypes.postgresql;
        }
        else if (String(dbSystem) === semanticConventions.DBSYSTEMVALUES_MONGODB) {
            dependencyData.Type = DependencyTypes.mongodb;
        }
        else if (String(dbSystem) === semanticConventions.DBSYSTEMVALUES_REDIS) {
            dependencyData.Type = DependencyTypes.redis;
        }
        else if (isSqlDB(String(dbSystem))) {
            dependencyData.Type = DependencyTypes.Sql;
        }
        else {
            dependencyData.Type = String(dbSystem);
        }
        const dbStatement = span.attributes[semanticConventions.SEMATTRS_DB_STATEMENT];
        const dbOperation = span.attributes[semanticConventions.SEMATTRS_DB_OPERATION];
        if (dbStatement) {
            dependencyData.Data = String(dbStatement);
        }
        else if (dbOperation) {
            dependencyData.Data = String(dbOperation);
        }
        const target = getDependencyTarget(span.attributes);
        const dbName = span.attributes[semanticConventions.SEMATTRS_DB_NAME];
        if (target) {
            dependencyData.Target = dbName ? `${target}|${dbName}` : `${target}`;
        }
        else {
            dependencyData.Target = dbName ? `${dbName}` : `${dbSystem}`;
        }
    }
    // grpc Dependency
    else if (rpcSystem) {
        if (rpcSystem === DependencyTypes.Wcf) {
            dependencyData.Type = DependencyTypes.Wcf;
        }
        else {
            dependencyData.Type = DependencyTypes.Grpc;
        }
        const grpcStatusCode = span.attributes[semanticConventions.SEMATTRS_RPC_GRPC_STATUS_CODE];
        if (grpcStatusCode) {
            dependencyData.ResultCode = Number(grpcStatusCode);
        }
        const target = getDependencyTarget(span.attributes);
        if (target) {
            dependencyData.Target = `${target}`;
        }
        else if (rpcSystem) {
            dependencyData.Target = String(rpcSystem);
        }
    }
    return dependencyData;
}
function getLogData(log) {
    const customDims = createCustomDimsFromAttributes(log.attributes);
    if (isExceptionTelemetry(log)) {
        return {
            // eslint-disable-next-line @typescript-eslint/no-base-to-string
            Message: String(log.attributes[semanticConventions.SEMATTRS_EXCEPTION_MESSAGE]),
            // eslint-disable-next-line @typescript-eslint/no-base-to-string
            StackTrace: String(log.attributes[semanticConventions.SEMATTRS_EXCEPTION_STACKTRACE]),
            CustomDimensions: customDims,
        };
    }
    else {
        return {
            // eslint-disable-next-line @typescript-eslint/no-base-to-string
            Message: String(log.body),
            CustomDimensions: customDims,
        };
    }
}
function getLogDocument(data, exceptionType) {
    if (isExceptionData(data) && exceptionType) {
        return {
            documentType: KnownDocumentType.Exception,
            exceptionMessage: data.Message,
            exceptionType: exceptionType,
            properties: mapToKeyValuePairList(data.CustomDimensions),
        };
    }
    else {
        // trace
        return {
            documentType: KnownDocumentType.Trace,
            message: data.Message,
            properties: mapToKeyValuePairList(data.CustomDimensions),
        };
    }
}
function isRequestData(data) {
    return data.Url !== undefined;
}
function isDependencyData(data) {
    return data.Target !== undefined;
}
function isTraceData(data) {
    return data.Message !== undefined && data.StackTrace === undefined;
}
function isExceptionData(data) {
    return data.StackTrace !== undefined;
}
function getSpanDocument(telemetryData) {
    let document = {
        documentType: KnownDocumentType.Request,
    };
    if (isRequestData(telemetryData)) {
        document = {
            documentType: KnownDocumentType.Request,
            name: telemetryData.Name,
            url: telemetryData.Url,
            responseCode: String(telemetryData.ResponseCode),
            duration: getIso8601Duration(telemetryData.Duration),
        };
    }
    else if (isDependencyData(telemetryData)) {
        document = {
            documentType: KnownDocumentType.RemoteDependency,
            name: telemetryData.Name,
            commandName: telemetryData.Data,
            resultCode: String(telemetryData.ResultCode),
            duration: getIso8601Duration(telemetryData.Duration),
        };
    }
    document.properties = mapToKeyValuePairList(telemetryData.CustomDimensions);
    return document;
}
function createCustomDimsFromAttributes(attributes) {
    const customDims = new Map();
    if (attributes) {
        for (const key of Object.keys(attributes)) {
            if (!(key.startsWith("_MS.") ||
                legacySemanticValues.includes(key) ||
                httpSemanticValues.includes(key))) {
                // eslint-disable-next-line @typescript-eslint/no-base-to-string
                customDims.set(key, String(attributes[key]));
            }
        }
    }
    return customDims;
}
function mapToKeyValuePairList(map) {
    const list = [];
    map.forEach((value, key) => {
        list.push({ key, value });
    });
    return list;
}
function getUrl(attributes) {
    if (!attributes) {
        return "";
    }
    const httpMethod = getHttpMethod(attributes);
    if (httpMethod) {
        const httpUrl = getHttpUrl(attributes);
        if (httpUrl) {
            return String(httpUrl);
        }
        else {
            const httpScheme = getHttpScheme(attributes);
            const httpTarget = getHttpTarget(attributes);
            if (httpScheme && httpTarget) {
                const httpHost = getHttpHost(attributes);
                if (httpHost) {
                    return `${httpScheme}://${httpHost}${httpTarget}`;
                }
                else {
                    const netPeerPort = getNetPeerPort(attributes);
                    if (netPeerPort) {
                        const netPeerName = getNetPeerName(attributes);
                        if (netPeerName) {
                            return `${httpScheme}://${netPeerName}:${netPeerPort}${httpTarget}`;
                        }
                        else {
                            const netPeerIp = getPeerIp(attributes);
                            if (netPeerIp) {
                                return `${httpScheme}://${netPeerIp}:${netPeerPort}${httpTarget}`;
                            }
                        }
                    }
                }
            }
        }
    }
    return "";
}
/**
 * UTC time the request was made. Expressed as the number of 100-nanosecond intervals that have elapsed since 12:00:00 midnight on January 1, 0001. This is used for clock skew calculations, so the value can never be stale (cached).
 *
 * @example
 * 8/5/2020 10:15:00 PM UTC =\> 637322625000000000
 * 8/5/2020 10:15:01 PM UTC =\> 637322625010000000
 */
function getTransmissionTime() {
    return (Date.now() + 62135596800000) * 10000;
}
function getMsFromFilterTimestampString(timestamp) {
    // The service side will return a timestamp in the following format:
    // [days].[hours]:[minutes]:[seconds]
    // the seconds may be a whole number or something like 7.89. 7.89 seconds translates to 7890 ms.
    // writing this method because date.getmilliseconds() returns incorrect result on large timestamps.
    // examples: "14.6:56:7.89" = 1234567890 ms, "0.0:0:0.2" = 200 ms
    const parts = timestamp.split(":");
    if (parts.length !== 3) {
        return NaN;
    }
    const seconds = parseFloat(parts[2]);
    const minutes = parseFloat(parts[1]);
    const firstPart = parts[0].split(".");
    if (firstPart.length !== 2) {
        return NaN;
    }
    const hours = parseFloat(firstPart[1]);
    const days = parseFloat(firstPart[0]);
    if (isNaN(days) || isNaN(hours) || isNaN(minutes) || isNaN(seconds)) {
        return NaN;
    }
    return seconds * 1000 + minutes * 60000 + hours * 3600000 + days * 86400000;
}
function getPeerIp(attributes) {
    if (attributes) {
        return String(attributes[semanticConventions.ATTR_NETWORK_PEER_ADDRESS] || attributes[semanticConventions.SEMATTRS_NET_PEER_IP]);
    }
    return;
}
function getUserAgent(attributes) {
    if (attributes) {
        return String(attributes[semanticConventions.ATTR_USER_AGENT_ORIGINAL] || attributes[semanticConventions.SEMATTRS_HTTP_USER_AGENT]);
    }
    return;
}
function getHttpUrl(attributes) {
    // Stable sem conv only supports populating url from `url.full`
    if (attributes) {
        return String(attributes[semanticConventions.ATTR_URL_FULL] || attributes[semanticConventions.SEMATTRS_HTTP_URL] || "");
    }
    return "";
}
function getHttpMethod(attributes) {
    if (attributes) {
        return String(attributes[semanticConventions.ATTR_HTTP_REQUEST_METHOD] || attributes[semanticConventions.SEMATTRS_HTTP_METHOD]);
    }
    return;
}
function getHttpStatusCode(attributes) {
    if (attributes) {
        return String(attributes[semanticConventions.ATTR_HTTP_RESPONSE_STATUS_CODE] || attributes[semanticConventions.SEMATTRS_HTTP_STATUS_CODE]);
    }
    return;
}
function getHttpScheme(attributes) {
    if (attributes) {
        return String(attributes[semanticConventions.ATTR_URL_SCHEME] || attributes[semanticConventions.SEMATTRS_HTTP_SCHEME]);
    }
    return;
}
function getHttpTarget(attributes) {
    if (attributes) {
        if (attributes[semanticConventions.ATTR_URL_PATH]) {
            return String(attributes[semanticConventions.ATTR_URL_PATH]);
        }
        if (attributes[semanticConventions.ATTR_URL_QUERY]) {
            return String(attributes[semanticConventions.ATTR_URL_QUERY]);
        }
        return String(attributes[semanticConventions.SEMATTRS_HTTP_TARGET] || "");
    }
    return "";
}
function getHttpHost(attributes) {
    if (attributes) {
        return String(attributes[semanticConventions.ATTR_SERVER_ADDRESS] || attributes[semanticConventions.SEMATTRS_HTTP_HOST]);
    }
    return;
}
function getNetPeerName(attributes) {
    if (attributes) {
        return String(attributes[semanticConventions.ATTR_CLIENT_ADDRESS] || attributes[semanticConventions.SEMATTRS_NET_PEER_NAME] || "");
    }
    return "";
}
function getNetHostPort(attributes) {
    if (attributes) {
        return String(attributes[semanticConventions.ATTR_SERVER_PORT] || attributes[semanticConventions.SEMATTRS_NET_HOST_PORT] || "");
    }
    return "";
}
function getNetPeerPort(attributes) {
    if (attributes) {
        return String(attributes[semanticConventions.ATTR_CLIENT_PORT] ||
            attributes[semanticConventions.ATTR_SERVER_PORT] ||
            attributes[semanticConventions.SEMATTRS_NET_PEER_PORT]);
    }
    return;
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
function getRequestDimensions(span) {
    const dimensions = getBaseDimensions(span.resource);
    dimensions.metricId = StandardMetricIds.REQUEST_DURATION;
    const statusCode = String(getHttpStatusCode(span.attributes));
    dimensions.requestResultCode = statusCode;
    // OTel treats 4xx request responses as UNSET SpanStatusCode, but we should count them as failed
    dimensions.requestSuccess =
        span.status.code !== api.SpanStatusCode.ERROR && (Number(statusCode) || 0) < 400 ? "True" : "False";
    if (isSyntheticLoad(span)) {
        dimensions.operationSynthetic = "True";
    }
    return convertDimensions(dimensions);
}
function getDependencyDimensions(span) {
    const dimensions = getBaseDimensions(span.resource);
    dimensions.metricId = StandardMetricIds.DEPENDENCIES_DURATION;
    const statusCode = String(getHttpStatusCode(span.attributes));
    dimensions.dependencyTarget = getDependencyTarget(span.attributes);
    dimensions.dependencyResultCode = statusCode;
    dimensions.dependencyType = "http";
    dimensions.dependencySuccess = span.status.code !== api.SpanStatusCode.ERROR ? "True" : "False";
    if (isSyntheticLoad(span)) {
        dimensions.operationSynthetic = "True";
    }
    return convertDimensions(dimensions);
}
function getExceptionDimensions(resource) {
    const dimensions = getBaseDimensions(resource);
    dimensions.metricId = StandardMetricIds.EXCEPTIONS_COUNT;
    return dimensions;
}
function getTraceDimensions(resource) {
    const dimensions = getBaseDimensions(resource);
    dimensions.metricId = StandardMetricIds.TRACES_COUNT;
    return dimensions;
}
function getBaseDimensions(resource) {
    const dimensions = {};
    dimensions.IsAutocollected = "True";
    if (resource) {
        dimensions.cloudRoleName = getCloudRole(resource);
        dimensions.cloudRoleInstance = getCloudRoleInstance(resource);
    }
    return dimensions;
}
// Get metric dependency target, avoiding high cardinality.
function getDependencyTarget(attributes) {
    if (!attributes) {
        return "";
    }
    const peerService = attributes[semanticConventions.SEMATTRS_PEER_SERVICE];
    const hostPort = getNetHostPort(attributes);
    const netPeerName = getNetPeerName(attributes);
    if (peerService) {
        return String(peerService);
    }
    else if (hostPort && netPeerName) {
        return `${netPeerName}:${hostPort}`;
    }
    else if (netPeerName) {
        return String(netPeerName);
    }
    return "";
}
function isSqlDB(dbSystem) {
    return (dbSystem === semanticConventions.DBSYSTEMVALUES_DB2 ||
        dbSystem === semanticConventions.DBSYSTEMVALUES_DERBY ||
        dbSystem === semanticConventions.DBSYSTEMVALUES_MARIADB ||
        dbSystem === semanticConventions.DBSYSTEMVALUES_MSSQL ||
        dbSystem === semanticConventions.DBSYSTEMVALUES_ORACLE ||
        dbSystem === semanticConventions.DBSYSTEMVALUES_SQLITE ||
        dbSystem === semanticConventions.DBSYSTEMVALUES_OTHER_SQL ||
        dbSystem === semanticConventions.DBSYSTEMVALUES_HSQLDB ||
        dbSystem === semanticConventions.DBSYSTEMVALUES_H2);
}
function isExceptionTelemetry(logRecord) {
    const baseType = logRecord.attributes["_MS.baseType"];
    // If Application Insights Legacy logs
    if (baseType && baseType === "ExceptionData") {
        return true;
    }
    else if (logRecord.attributes[semanticConventions.SEMATTRS_EXCEPTION_MESSAGE] ||
        logRecord.attributes[semanticConventions.SEMATTRS_EXCEPTION_TYPE]) {
        return true;
    }
    return false;
}
function isTraceTelemetry(logRecord) {
    const baseType = logRecord.attributes["_MS.baseType"];
    // If Application Insights Legacy logs
    if (baseType && baseType === "MessageData") {
        return true;
    }
    else if (!logRecord.attributes[semanticConventions.SEMATTRS_EXCEPTION_MESSAGE] &&
        !logRecord.attributes[semanticConventions.SEMATTRS_EXCEPTION_TYPE]) {
        return true;
    }
    return false;
}
function isSyntheticLoad(record) {
    // eslint-disable-next-line @typescript-eslint/no-base-to-string
    const userAgent = String(getUserAgent(record.attributes));
    return userAgent !== null && userAgent.includes("AlwaysOn") ? true : false;
}
function convertDimensions(dimensions) {
    const convertedDimensions = {};
    for (const dim in dimensions) {
        convertedDimensions[StandardMetricPropertyNames[dim]] = dimensions[dim];
    }
    return convertedDimensions;
}
// to get physical memory bytes
function getPhysicalMemory() {
    return process.memoryUsage.rss();
}
// This function can get the normalized cpu, but it assumes that after this function is called,
// that the process.hrtime.bigint() & process.cpuUsage() are called/stored to be used as the
// parameters for the next call.
function getProcessorTimeNormalized(lastHrTime, lastCpuUsage) {
    let numCpus = os__namespace.cpus().length;
    const usageDif = process.cpuUsage(lastCpuUsage);
    const elapsedTimeNs = process.hrtime.bigint() - lastHrTime;
    const usageDifMs = (usageDif.user + usageDif.system) / 1000.0;
    const elapsedTimeMs = elapsedTimeNs === BigInt(0) ? 1 : Number(elapsedTimeNs) / 1000000.0;
    // just for division safety, don't know a case in which this would actually happen
    numCpus = numCpus === 0 ? 1 : numCpus;
    return (usageDifMs / elapsedTimeMs / numCpus) * 100;
}
/**
 * Gets the cloud role name based on the resource attributes
 */
function getCloudRole(resource) {
    let cloudRole = "";
    // Service attributes
    const serviceName = resource.attributes[semanticConventions.SEMRESATTRS_SERVICE_NAME];
    const serviceNamespace = resource.attributes[semanticConventions.SEMRESATTRS_SERVICE_NAMESPACE];
    if (serviceName) {
        // Custom Service name provided by customer is highest precedence
        if (!String(serviceName).startsWith("unknown_service")) {
            if (serviceNamespace) {
                return `${serviceNamespace}.${serviceName}`;
            }
            else {
                return String(serviceName);
            }
        }
        else {
            // Service attributes will be only used if K8S attributes are not present
            if (serviceNamespace) {
                cloudRole = `${serviceNamespace}.${serviceName}`;
            }
            else {
                cloudRole = String(serviceName);
            }
        }
    }
    // Kubernetes attributes should take precedence
    const kubernetesDeploymentName = resource.attributes[semanticConventions.SEMRESATTRS_K8S_DEPLOYMENT_NAME];
    if (kubernetesDeploymentName) {
        return String(kubernetesDeploymentName);
    }
    const kuberneteReplicasetName = resource.attributes[semanticConventions.SEMRESATTRS_K8S_REPLICASET_NAME];
    if (kuberneteReplicasetName) {
        return String(kuberneteReplicasetName);
    }
    const kubernetesStatefulSetName = resource.attributes[semanticConventions.SEMRESATTRS_K8S_STATEFULSET_NAME];
    if (kubernetesStatefulSetName) {
        return String(kubernetesStatefulSetName);
    }
    const kubernetesJobName = resource.attributes[semanticConventions.SEMRESATTRS_K8S_JOB_NAME];
    if (kubernetesJobName) {
        return String(kubernetesJobName);
    }
    const kubernetesCronjobName = resource.attributes[semanticConventions.SEMRESATTRS_K8S_CRONJOB_NAME];
    if (kubernetesCronjobName) {
        return String(kubernetesCronjobName);
    }
    const kubernetesDaemonsetName = resource.attributes[semanticConventions.SEMRESATTRS_K8S_DAEMONSET_NAME];
    if (kubernetesDaemonsetName) {
        return String(kubernetesDaemonsetName);
    }
    return cloudRole;
}
/**
 * Gets the cloud role instance based on the resource attributes
 */
function getCloudRoleInstance(resource) {
    // Kubernetes attributes should take precedence
    const kubernetesPodName = resource.attributes[semanticConventions.SEMRESATTRS_K8S_POD_NAME];
    if (kubernetesPodName) {
        return String(kubernetesPodName);
    }
    // Service attributes
    const serviceInstanceId = resource.attributes[semanticConventions.SEMRESATTRS_SERVICE_INSTANCE_ID];
    if (serviceInstanceId) {
        return String(serviceInstanceId);
    }
    // Default
    return os__namespace && os__namespace.hostname();
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * Azure Monitor Standard Metrics
 * @internal
 */
class StandardMetrics {
    /**
     * Initializes a new instance of the StandardMetrics class.
     * @param config - Distro configuration.
     * @param options - Standard Metrics options.
     */
    constructor(config, options) {
        this._collectionInterval = 60000; // 60 seconds
        this._config = config;
        this._azureExporter = new monitorOpentelemetryExporter.AzureMonitorMetricExporter(this._config.azureMonitorExporterOptions);
        const metricReaderOptions = {
            exporter: this._azureExporter,
            exportIntervalMillis: (options === null || options === void 0 ? void 0 : options.collectionInterval) || this._collectionInterval,
        };
        this._metricReader = new sdkMetrics.PeriodicExportingMetricReader(metricReaderOptions);
        const meterProviderConfig = {
            resource: this._config.resource,
            readers: [this._metricReader],
        };
        this._meterProvider = new sdkMetrics.MeterProvider(meterProviderConfig);
        this._meter = this._meterProvider.getMeter("AzureMonitorStandardMetricsMeter");
        this._incomingRequestDurationHistogram = this._meter.createHistogram(StandardMetricIds.REQUEST_DURATION, {
            valueType: api.ValueType.DOUBLE,
        });
        this._outgoingRequestDurationHistogram = this._meter.createHistogram(StandardMetricIds.DEPENDENCIES_DURATION, {
            valueType: api.ValueType.DOUBLE,
        });
        this._exceptionsCounter = this._meter.createCounter(StandardMetricIds.EXCEPTIONS_COUNT, {
            valueType: api.ValueType.INT,
        });
        this._tracesCounter = this._meter.createCounter(StandardMetricIds.TRACES_COUNT, {
            valueType: api.ValueType.INT,
        });
    }
    /**
     * Shutdown Meter Provider it will return no-op Meters after being called.
     */
    shutdown() {
        this._meterProvider.shutdown();
    }
    /**
     * Force flush Meter Provider.
     */
    async flush() {
        await this._meterProvider.forceFlush();
    }
    /**
     *Get OpenTelemetry MeterProvider
     */
    getMeterProvider() {
        return this._meterProvider;
    }
    /**
     * Add extra attributes to Span so Ingestion doesn't aggregate the data again
     * @internal
     */
    markSpanAsProcessed(span) {
        if (span.kind === api.SpanKind.CLIENT) {
            span.setAttributes({
                "_MS.ProcessedByMetricExtractors": "(Name:'Dependencies', Ver:'1.1')",
            });
        }
        else if (span.kind === api.SpanKind.SERVER) {
            span.setAttributes({
                "_MS.ProcessedByMetricExtractors": "(Name:'Requests', Ver:'1.1')",
            });
        }
    }
    /**
     * Record Span metrics
     * @internal
     */
    recordSpan(span) {
        const durationMs = span.duration[0];
        if (span.kind === api.SpanKind.SERVER) {
            this._incomingRequestDurationHistogram.record(durationMs, getRequestDimensions(span));
        }
        else {
            this._outgoingRequestDurationHistogram.record(durationMs, getDependencyDimensions(span));
        }
        if (span.events) {
            span.events.forEach((event) => {
                event.attributes = event.attributes || {};
                if (event.name === "exception") {
                    event.attributes["_MS.ProcessedByMetricExtractors"] = "(Name:'Exceptions', Ver:'1.1')";
                    this._exceptionsCounter.add(1, getExceptionDimensions(span.resource));
                }
                else {
                    event.attributes["_MS.ProcessedByMetricExtractors"] = "(Name:'Traces', Ver:'1.1')";
                    this._tracesCounter.add(1, getTraceDimensions(span.resource));
                }
            });
        }
    }
    /**
     * Record LogRecord metrics, add attribute so data is not aggregated again in ingestion
     * @internal
     */
    recordLog(logRecord) {
        if (isSyntheticLoad(logRecord)) {
            logRecord.setAttribute("operation/synthetic", "True");
        }
        if (isExceptionTelemetry(logRecord)) {
            logRecord.setAttribute("_MS.ProcessedByMetricExtractors", "(Name:'Exceptions', Ver:'1.1')");
            this._exceptionsCounter.add(1, getExceptionDimensions(logRecord.resource));
        }
        else if (isTraceTelemetry(logRecord)) {
            logRecord.setAttribute("_MS.ProcessedByMetricExtractors", "(Name:'Traces', Ver:'1.1')");
            this._tracesCounter.add(1, getTraceDimensions(logRecord.resource));
        }
    }
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
const applicationInsightsResource = "https://monitor.azure.com//.default";
/**
 * Quickpulse sender class
 * @internal
 */
class QuickpulseSender {
    constructor(options) {
        // Build endpoint using provided configuration or default values
        this.endpointUrl = options.endpointUrl;
        this.quickpulseClientOptions = {
            endpoint: this.endpointUrl,
        };
        this.instrumentationKey = options.instrumentationKey;
        if (options.credential) {
            this.quickpulseClientOptions.credential = options.credential;
            // Add credentialScopes
            if (options.credentialScopes) {
                this.quickpulseClientOptions.credentialScopes = options.credentialScopes;
            }
            else {
                // Default
                this.quickpulseClientOptions.credentialScopes = [applicationInsightsResource];
            }
        }
        this.quickpulseClient = new QuickpulseClient(this.quickpulseClientOptions);
        // Handle redirects in HTTP Sender
        this.quickpulseClient.pipeline.removePolicy({ name: coreRestPipeline.redirectPolicyName });
    }
    /**
     * isSubscribed Quickpulse service
     * @internal
     */
    async isSubscribed(optionalParams) {
        try {
            const response = await this.quickpulseClient.isSubscribed(this.endpointUrl, this.instrumentationKey, optionalParams);
            return response;
        }
        catch (error) {
            const restError = error;
            api.diag.info("Failed to ping Quickpulse service", restError.message);
        }
        return;
    }
    /**
     * publish Quickpulse service
     * @internal
     */
    async publish(optionalParams) {
        try {
            const response = await this.quickpulseClient.publish(this.endpointUrl, this.instrumentationKey, optionalParams);
            return response;
        }
        catch (error) {
            const restError = error;
            api.diag.warn("Failed to post Quickpulse service", restError.message);
        }
        return;
    }
    handlePermanentRedirect(location) {
        if (location) {
            const locUrl = new url.URL(location);
            if (locUrl && locUrl.host) {
                this.endpointUrl = "https://" + locUrl.host;
            }
        }
    }
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * Quickpulse Metric Exporter.
 */
class QuickpulseMetricExporter {
    /**
     * Initializes a new instance of the AzureMonitorMetricExporter class.
     * @param AzureExporterConfig - Exporter configuration.
     */
    constructor(options) {
        this.sender = new QuickpulseSender({
            endpointUrl: options.endpointUrl,
            instrumentationKey: options.instrumentationKey,
            credential: options.credential,
            credentialScopes: options.credentialScopes,
        });
        this.postCallback = options.postCallback;
        this.getDocumentsFn = options.getDocumentsFn;
        this.baseMonitoringDataPoint = options.baseMonitoringDataPoint;
        this.getErrorsFn = options.getErrorsFn;
        this.etag = "";
        this.getDerivedMetricValuesFn = options.getDerivedMetricValuesFn;
        api.diag.debug("QuickpulseMetricExporter was successfully setup");
    }
    /**
     * Export OpenTelemetry resource metrics.
     * @param metrics - Resource metrics to export.
     * @param resultCallback - Result callback.
     */
    // eslint-disable-next-line @typescript-eslint/no-misused-promises
    async export(metrics, resultCallback) {
        api.diag.info(`Exporting Live metrics(s). Converting to envelopes...`);
        const optionalParams = {
            monitoringDataPoints: resourceMetricsToQuickpulseDataPoint(metrics, this.baseMonitoringDataPoint, this.getDocumentsFn(), this.getErrorsFn(), this.getDerivedMetricValuesFn()),
            transmissionTime: getTransmissionTime(),
            configurationEtag: this.etag,
        };
        // Supress tracing until OpenTelemetry Metrics SDK support it
        await api.context.with(core.suppressTracing(api.context.active()), async () => {
            try {
                this.postCallback(await this.sender.publish(optionalParams));
                resultCallback({ code: core.ExportResultCode.SUCCESS });
            }
            catch (error) {
                this.postCallback(undefined);
                resultCallback({ code: core.ExportResultCode.FAILED });
            }
        });
    }
    /**
     * Shutdown Exporter.
     */
    async shutdown() {
        api.diag.info("QuickpulseMetricExporter shutting down");
        return Promise.resolve();
    }
    /**
     * Select aggregation temporality
     */
    selectAggregationTemporality(instrumentType) {
        if (instrumentType === sdkMetrics.InstrumentType.UP_DOWN_COUNTER ||
            instrumentType === sdkMetrics.InstrumentType.OBSERVABLE_UP_DOWN_COUNTER) {
            return sdkMetrics.AggregationTemporality.CUMULATIVE;
        }
        return sdkMetrics.AggregationTemporality.DELTA;
    }
    /**
     * Force flush
     */
    async forceFlush() {
        return Promise.resolve();
    }
    /**
     * Get Sender
     */
    getSender() {
        return this.sender;
    }
    setEtag(etag) {
        this.etag = etag;
    }
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * ConnectionString parser.
 * @internal
 */
class ConnectionStringParser {
    static parse(connectionString) {
        if (!connectionString) {
            return {};
        }
        const kvPairs = connectionString.split(ConnectionStringParser.FIELDS_SEPARATOR);
        let isValid = true;
        const result = kvPairs.reduce((fields, kv) => {
            const kvParts = kv.split(ConnectionStringParser.FIELD_KEY_VALUE_SEPARATOR);
            if (kvParts.length === 2) {
                // only save fields with valid formats
                const key = kvParts[0].toLowerCase();
                const value = kvParts[1];
                return Object.assign(Object.assign({}, fields), { [key]: value });
            }
            api.diag.error(`Connection string key-value pair is invalid: ${kv}`, `Entire connection string will be discarded`, connectionString);
            isValid = false;
            return fields;
        }, {});
        if (isValid && Object.keys(result).length > 0) {
            // this is a valid connection string, so parse the results
            if (result.endpointsuffix) {
                // use endpoint suffix where overrides are not provided
                const locationPrefix = result.location ? `${result.location}.` : "";
                result.ingestionendpoint =
                    result.ingestionendpoint || `https://${locationPrefix}dc.${result.endpointsuffix}`;
                result.liveendpoint =
                    result.liveendpoint || `https://${locationPrefix}live.${result.endpointsuffix}`;
            }
            result.ingestionendpoint = result.ingestionendpoint
                ? ConnectionStringParser.sanitizeUrl(result.ingestionendpoint)
                : DEFAULT_BREEZE_ENDPOINT;
            result.liveendpoint = result.liveendpoint
                ? ConnectionStringParser.sanitizeUrl(result.liveendpoint)
                : DEFAULT_LIVEMETRICS_ENDPOINT;
            if (result.authorization && result.authorization.toLowerCase() !== "ikey") {
                api.diag.warn(`Connection String contains an unsupported 'Authorization' value: ${result.authorization}. Defaulting to 'Authorization=ikey'. Instrumentation Key ${result.instrumentationkey}`);
            }
        }
        else {
            api.diag.error("An invalid connection string was passed in. There may be telemetry loss", connectionString);
        }
        return result;
    }
    static sanitizeUrl(url) {
        let newUrl = url.trim();
        if (newUrl.indexOf("https://") < 0) {
            // Try to update http to https
            newUrl = newUrl.replace("http://", "https://");
        }
        // Remove final slash if present
        if (newUrl[newUrl.length - 1] === "/") {
            newUrl = newUrl.slice(0, -1);
        }
        return newUrl;
    }
    static validateInstrumentationKey(iKey) {
        if (iKey.startsWith("InstrumentationKey=")) {
            const startIndex = iKey.indexOf("InstrumentationKey=") + "InstrumentationKey=".length;
            const endIndex = iKey.indexOf(";", startIndex);
            iKey = iKey.substring(startIndex, endIndex);
        }
        const UUID_Regex = "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$";
        const regexp = new RegExp(UUID_Regex);
        return regexp.test(iKey);
    }
}
ConnectionStringParser.FIELDS_SEPARATOR = ";";
ConnectionStringParser.FIELD_KEY_VALUE_SEPARATOR = "=";

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
let instance;
class StatsbeatConfiguration {
    constructor() {
        // Initial Statsbeat options
        this.initializedByShim = false;
        this.currentStatsbeatInstrumentations = {};
        this.currentStatsbeatFeatures = {};
        this.setStatsbeatFeatures = (statsbeatInstrumentations, statsbeatFeatures) => {
            let statsbeatEnv;
            try {
                statsbeatEnv = JSON.parse(process.env[AZURE_MONITOR_STATSBEAT_FEATURES] || "{}");
            }
            catch (error) {
                Logger.getInstance().error("Failed to parse statsbeat config environment variable.", error);
            }
            this.currentStatsbeatInstrumentations = Object.assign(Object.assign({}, this.currentStatsbeatInstrumentations), statsbeatInstrumentations);
            this.currentStatsbeatFeatures = Object.assign(Object.assign({}, this.currentStatsbeatFeatures), statsbeatFeatures);
            // Set the statsbeat options for community instrumentations based on the environment variable
            statsbeatInstrumentations = Object.assign(Object.assign({}, this.currentStatsbeatInstrumentations), { amqplib: statsbeatEnv.instrumentation & StatsbeatInstrumentation.AMQPLIB ? true : false, cucumber: statsbeatEnv.instrumentation & StatsbeatInstrumentation.CUCUMBER ? true : false, dataloader: statsbeatEnv.instrumentation & StatsbeatInstrumentation.DATALOADER ? true : false, fs: statsbeatEnv.instrumentation & StatsbeatInstrumentation.FS ? true : false, lruMemoizer: statsbeatEnv.instrumentation & StatsbeatInstrumentation.LRU_MEMOIZER ? true : false, mongoose: statsbeatEnv.instrumentation & StatsbeatInstrumentation.MONGOOSE ? true : false, runtimeNode: statsbeatEnv.instrumentation & StatsbeatInstrumentation.RUNTIME_NODE ? true : false, socketIo: statsbeatEnv.instrumentation & StatsbeatInstrumentation.SOCKET_IO ? true : false, tedious: statsbeatEnv.instrumentation & StatsbeatInstrumentation.TEDIOUS ? true : false, undici: statsbeatEnv.instrumentation & StatsbeatInstrumentation.UNDICI ? true : false, cassandra: statsbeatEnv.instrumentation & StatsbeatInstrumentation.CASSANDRA ? true : false, connect: statsbeatEnv.instrumentation & StatsbeatInstrumentation.CONNECT ? true : false, dns: statsbeatEnv.instrumentation & StatsbeatInstrumentation.DNS ? true : false, express: statsbeatEnv.instrumentation & StatsbeatInstrumentation.EXPRESS ? true : false, fastify: statsbeatEnv.instrumentation & StatsbeatInstrumentation.FASTIFY ? true : false, genericPool: statsbeatEnv.instrumentation & StatsbeatInstrumentation.GENERIC_POOL ? true : false, graphql: statsbeatEnv.instrumentation & StatsbeatInstrumentation.GRAPHQL ? true : false, hapi: statsbeatEnv.instrumentation & StatsbeatInstrumentation.HAPI ? true : false, ioredis: statsbeatEnv.instrumentation & StatsbeatInstrumentation.IOREDIS ? true : false, knex: statsbeatEnv.instrumentation & StatsbeatInstrumentation.KNEX ? true : false, koa: statsbeatEnv.instrumentation & StatsbeatInstrumentation.KOA ? true : false, memcached: statsbeatEnv.instrumentation & StatsbeatInstrumentation.MEMCACHED ? true : false, mysql2: statsbeatEnv.instrumentation & StatsbeatInstrumentation.MYSQL2 ? true : false, nestjsCore: statsbeatEnv.instrumentation & StatsbeatInstrumentation.NESTJS_CORE ? true : false, net: statsbeatEnv.instrumentation & StatsbeatInstrumentation.NET ? true : false, pino: statsbeatEnv.instrumentation & StatsbeatInstrumentation.PINO ? true : false, restify: statsbeatEnv.instrumentation & StatsbeatInstrumentation.RESTIFY ? true : false, router: statsbeatEnv.instrumentation & StatsbeatInstrumentation.ROUTER ? true : false });
            let instrumentationBitMap = StatsbeatInstrumentation.NONE;
            const instrumentationArray = Object.entries(statsbeatInstrumentations).map((entry) => {
                return { option: entry[0], value: entry[1] };
            });
            // Map the instrumentation options to a bit map
            for (let i = 0; i < instrumentationArray.length; i++) {
                if (instrumentationArray[i].value) {
                    instrumentationBitMap |= 2 ** i;
                }
            }
            // Create feature bit map
            let featureBitMap = StatsbeatFeature.NONE;
            if (this.initializedByShim) {
                this.currentStatsbeatFeatures.shim = true;
            }
            else {
                this.currentStatsbeatFeatures.distro = true;
            }
            if (statsbeatFeatures.liveMetrics) {
                this.currentStatsbeatFeatures.liveMetrics = true;
            }
            const featureArray = Object.entries(this.currentStatsbeatFeatures).map((entry) => {
                return { option: entry[0], value: entry[1] };
            });
            // Map the feature options to a bit map
            for (let i = 0; i < featureArray.length; i++) {
                if (featureArray[i].value) {
                    featureBitMap |= StatsbeatFeaturesMap.get(featureArray[i].option);
                }
            }
            // Merge old statsbeat options with new statsbeat options overriding any common properties
            try {
                const currentFeaturesBitMap = Number(process.env[AZURE_MONITOR_STATSBEAT_FEATURES]);
                if (!isNaN(currentFeaturesBitMap)) {
                    featureBitMap |= currentFeaturesBitMap;
                }
                process.env[AZURE_MONITOR_STATSBEAT_FEATURES] = JSON.stringify({
                    instrumentation: instrumentationBitMap,
                    feature: featureBitMap,
                });
            }
            catch (error) {
                Logger.getInstance().error("Failed call to JSON.stringify.", error);
            }
        };
        // Check for shim initialization upon construction
        try {
            if (JSON.parse(process.env[AZURE_MONITOR_STATSBEAT_FEATURES] || "{}").feature &
                StatsbeatFeature.SHIM) {
                this.initializedByShim = true;
            }
        }
        catch (error) {
            Logger.getInstance().error("Failed to parse statsbeat config environment variable.", error);
        }
    }
}
/**
 * Singleton Statsbeat instance.
 * @internal
 */
function getInstance() {
    if (!instance) {
        instance = new StatsbeatConfiguration();
    }
    return instance;
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
class Filter {
    renameExceptionFieldNamesForFiltering(filterConjunctionGroupInfo) {
        filterConjunctionGroupInfo.filters.forEach((filter) => {
            if (filter.fieldName.startsWith("Exception.")) {
                filter.fieldName = filter.fieldName.replace("Exception.", "");
            }
        });
    }
    checkMetricFilters(derivedMetricInfo, data) {
        if (derivedMetricInfo.filterGroups.length === 0) {
            // This should never happen - even when a user does not add filter pills to the derived metric,
            // the filterGroups array should have one filter group with an empty array of filters.
            return true;
        }
        // Haven't yet seen any case where there is more than one filter group in a derived metric info.
        // Just to be safe, handling the multiple filter conjunction group case as an or operation.
        let matched = false;
        derivedMetricInfo.filterGroups.forEach((filterConjunctionGroup) => {
            matched = matched || this.checkFilterConjunctionGroup(filterConjunctionGroup, data);
        });
        return matched;
    }
    checkFilterConjunctionGroup(filterConjunctionGroupInfo, data) {
        // All of the filters need to match for this to return true (and operation).
        for (const filter of filterConjunctionGroupInfo.filters) {
            if (!this.checkFilter(filter, data)) {
                return false;
            }
        }
        return true;
    }
    checkFilter(filter, data) {
        if (filter.fieldName === "*") {
            // Any field
            return this.checkAnyFieldFilter(filter, data);
        }
        else if (filter.fieldName.startsWith("CustomDimensions.")) {
            return this.checkCustomDimFilter(filter, data);
        }
        else {
            let dataValue;
            // use filter.fieldname to get the property of data to query
            if (isRequestData(data)) {
                dataValue = data[filter.fieldName];
            }
            else if (isDependencyData(data)) {
                dataValue = data[filter.fieldName];
            }
            else if (isExceptionData(data)) {
                dataValue = data[filter.fieldName];
            }
            else if (isTraceData(data)) {
                dataValue = data[filter.fieldName];
            }
            else {
                return false; // should not reach here
            }
            if (filter.fieldName === KnownRequestColumns.Success.toString()) {
                if (filter.predicate === KnownPredicateType.Equal.toString()) {
                    return dataValue === (filter.comparand.toLowerCase() === "true");
                }
                else if (filter.predicate === KnownPredicateType.NotEqual.toString()) {
                    return dataValue !== (filter.comparand.toLowerCase() === "true");
                }
            }
            else if (filter.fieldName === KnownDependencyColumns.ResultCode.toString() ||
                filter.fieldName === KnownRequestColumns.ResponseCode.toString() ||
                filter.fieldName === KnownDependencyColumns.Duration.toString()) {
                const comparand = filter.fieldName === KnownDependencyColumns.Duration.toString()
                    ? getMsFromFilterTimestampString(filter.comparand)
                    : parseFloat(filter.comparand);
                switch (filter.predicate) {
                    case KnownPredicateType.Equal.toString():
                        return dataValue === comparand;
                    case KnownPredicateType.NotEqual.toString():
                        return dataValue !== comparand;
                    case KnownPredicateType.GreaterThan.toString():
                        return dataValue > comparand;
                    case KnownPredicateType.GreaterThanOrEqual.toString():
                        return dataValue >= comparand;
                    case KnownPredicateType.LessThan.toString():
                        return dataValue < comparand;
                    case KnownPredicateType.LessThanOrEqual.toString():
                        return dataValue <= comparand;
                    default:
                        return false;
                }
            }
            else {
                // string fields
                return this.stringCompare(dataValue, filter.comparand, filter.predicate);
            }
        }
        return false;
    }
    checkAnyFieldFilter(filter, data) {
        const properties = Object.keys(data);
        // At this point, the only predicates possible to pass in are Contains and DoesNotContain
        // At config validation time the predicate is checked to be one of these two.
        for (const property of properties) {
            if (property === "CustomDimensions") {
                for (const value of data.CustomDimensions.values()) {
                    if (this.stringCompare(value, filter.comparand, filter.predicate)) {
                        return true;
                    }
                }
            }
            else {
                // @ts-expect-error - data can be any type of telemetry data and we know property is a valid key
                const value = String(data[property]);
                if (this.stringCompare(value, filter.comparand, filter.predicate)) {
                    return true;
                }
            }
        }
        return false;
    }
    checkCustomDimFilter(filter, data) {
        const fieldName = filter.fieldName.replace("CustomDimensions.", "");
        let value;
        if (data.CustomDimensions.has(fieldName)) {
            value = data.CustomDimensions.get(fieldName);
        }
        else {
            return false; // the asked for field is not present in the custom dimensions
        }
        return this.stringCompare(value, filter.comparand, filter.predicate);
    }
    stringCompare(dataValue, comparand, predicate) {
        switch (predicate) {
            case KnownPredicateType.Equal.toString():
                return dataValue === comparand;
            case KnownPredicateType.NotEqual.toString():
                return dataValue !== comparand;
            case KnownPredicateType.Contains.toString(): {
                const lowerDataValue = dataValue.toLowerCase();
                const lowerComparand = comparand.toLowerCase();
                return lowerDataValue.includes(lowerComparand);
            }
            case KnownPredicateType.DoesNotContain.toString(): {
                const lowerDataValue = dataValue.toLowerCase();
                const lowerComparand = comparand.toLowerCase();
                return !lowerDataValue.includes(lowerComparand);
            }
            default:
                return false;
        }
    }
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
class TelemetryTypeError extends Error {
    constructor(message) {
        super(message);
        this.name = "TelemetryTypeError";
    }
}
class UnexpectedFilterCreateError extends Error {
    constructor(message) {
        super(message);
        this.name = "UnexpectedFilterCreateError";
    }
}
class DuplicateMetricIdError extends Error {
    constructor(message) {
        super(message);
        this.name = "DuplicateMetricIdError";
    }
}
class MetricFailureToCreateError extends Error {
    constructor(message) {
        super(message);
        this.name = "MetricFailureToCreateError";
    }
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
const knownStringColumns = new Set([
    KnownRequestColumns.Url,
    KnownRequestColumns.Name,
    KnownDependencyColumns.Target,
    KnownDependencyColumns.Type,
    KnownDependencyColumns.Data,
    "Message",
    "Exception.Message",
    "Exception.StackTrace",
]);
class Validator {
    validateTelemetryType(telemetryType) {
        if (telemetryType === KnownTelemetryType.PerformanceCounter.toString()) {
            throw new TelemetryTypeError("The telemetry type PerformanceCounter was specified, but this distro does not send performance counters to quickpulse.");
        }
        else if (telemetryType === KnownTelemetryType.Event.toString()) {
            throw new TelemetryTypeError("The telemetry type Event was specified, but this telemetry type is not supported via OpenTelemetry.");
        }
        else if (telemetryType === KnownTelemetryType.Metric.toString()) {
            throw new TelemetryTypeError("The telemetry type Metric was specified, but this distro does not send custom live metrics to quickpulse.");
        }
        else if (!(telemetryType in KnownTelemetryType)) {
            throw new TelemetryTypeError(`'${telemetryType}' is not a valid telemetry type.`);
        }
    }
    checkCustomMetricProjection(derivedMetricInfo) {
        if (derivedMetricInfo.projection.startsWith("CustomMetrics.")) {
            throw new UnexpectedFilterCreateError("The Projection of a customMetric property is not supported via OpenTelemetry.");
        }
    }
    validateMetricFilters(derivedMetricInfo) {
        derivedMetricInfo.filterGroups.forEach((filterGroup) => {
            filterGroup.filters.forEach((filter) => {
                this.validateFieldNames(filter.fieldName, derivedMetricInfo.telemetryType);
                this.validatePredicateAndComparand(filter);
            });
        });
    }
    validateDocumentFilters(documentFilterConjuctionGroupInfo) {
        const filterConjunctionGroupInfo = documentFilterConjuctionGroupInfo.filters;
        filterConjunctionGroupInfo.filters.forEach((filter) => {
            this.validateFieldNames(filter.fieldName, documentFilterConjuctionGroupInfo.telemetryType);
            this.validatePredicateAndComparand(filter);
        });
    }
    isCustomDimOrAnyField(fieldName) {
        return fieldName.startsWith("CustomDimensions.") || fieldName === "*";
    }
    validateFieldNames(fieldName, telemetryType) {
        if (fieldName === "") {
            throw new UnexpectedFilterCreateError("A filter must have a field name.");
        }
        if (fieldName.startsWith("CustomMetrics.")) {
            throw new UnexpectedFilterCreateError("Filtering of a customMetric property is not supported via OpenTelemetry.");
        }
        switch (telemetryType) {
            case KnownTelemetryType.Request.toString():
                if (!this.isCustomDimOrAnyField(fieldName) && !(fieldName in KnownRequestColumns)) {
                    throw new UnexpectedFilterCreateError(`'${fieldName}' is not a valid field name for the telemetry type Request.`);
                }
                break;
            case KnownTelemetryType.Dependency.toString():
                if (!this.isCustomDimOrAnyField(fieldName) && !(fieldName in KnownDependencyColumns)) {
                    throw new UnexpectedFilterCreateError(`'${fieldName}' is not a valid field name for the telemetry type Dependency.`);
                }
                break;
            case KnownTelemetryType.Exception.toString():
                if (!this.isCustomDimOrAnyField(fieldName) &&
                    fieldName !== "Exception.Message" &&
                    fieldName !== "Exception.StackTrace") {
                    throw new UnexpectedFilterCreateError(`'${fieldName}' is not a valid field name for the telemetry type Exception.`);
                }
                break;
            case KnownTelemetryType.Trace.toString():
                if (!this.isCustomDimOrAnyField(fieldName) && fieldName !== "Message") {
                    throw new UnexpectedFilterCreateError(`'${fieldName}' is not a valid field name for the telemetry type Trace.`);
                }
                break;
            default:
                throw new TelemetryTypeError(`'${telemetryType}' is not a supported telemetry type.`);
        }
    }
    validatePredicateAndComparand(filter) {
        if (!(filter.predicate in KnownPredicateType)) {
            throw new UnexpectedFilterCreateError(`'${filter.predicate}' is not a valid predicate.`);
        }
        else if (filter.comparand === "") {
            throw new UnexpectedFilterCreateError(`A filter must have a comparand. FilterName: '${filter.fieldName}' Predicate: '${filter.predicate}' Comparand: '${filter.comparand}'`);
        }
        else if (filter.fieldName === "*" &&
            !(filter.predicate === KnownPredicateType.Contains.toString() ||
                filter.predicate === KnownPredicateType.DoesNotContain.toString())) {
            throw new UnexpectedFilterCreateError(`The predicate '${filter.predicate}' is not supported for the field name '*'`);
        }
        else if (filter.fieldName === KnownDependencyColumns.ResultCode.toString() ||
            filter.fieldName === KnownRequestColumns.ResponseCode.toString() ||
            filter.fieldName === KnownDependencyColumns.Duration.toString()) {
            if (filter.predicate === KnownPredicateType.Contains.toString() ||
                filter.predicate === KnownPredicateType.DoesNotContain.toString()) {
                throw new UnexpectedFilterCreateError(`The predicate '${filter.predicate}' is not supported for the field name '${filter.fieldName}'`);
            }
            // Duration comparand should be a timestamp; Response/ResultCode comparand should be interpreted as double.
            if (filter.fieldName === KnownDependencyColumns.Duration.toString()) {
                if (isNaN(getMsFromFilterTimestampString(filter.comparand))) {
                    throw new UnexpectedFilterCreateError(`The comparand '${filter.comparand}' can't be converted to a double (ms).`);
                }
            }
            else if (isNaN(parseFloat(filter.comparand))) {
                throw new UnexpectedFilterCreateError(`The comparand '${filter.comparand}' can't be converted to a double.`);
            }
        }
        else if (knownStringColumns.has(filter.fieldName) ||
            filter.fieldName.startsWith("CustomDimensions.")) {
            if (filter.predicate === KnownPredicateType.GreaterThan.toString() ||
                filter.predicate === KnownPredicateType.GreaterThanOrEqual.toString() ||
                filter.predicate === KnownPredicateType.LessThan.toString() ||
                filter.predicate === KnownPredicateType.LessThanOrEqual.toString()) {
                throw new UnexpectedFilterCreateError(`The predicate '${filter.predicate}' is not supported for the field name '${filter.fieldName}'. If this is a custom dimension, it would be treated as string.`);
            }
        }
        else if (filter.fieldName === KnownRequestColumns.Success.toString()) {
            if (filter.predicate !== KnownPredicateType.Equal.toString() &&
                filter.predicate !== KnownPredicateType.NotEqual.toString()) {
                throw new UnexpectedFilterCreateError(`The predicate '${filter.predicate}' is not supported for the field name '${filter.fieldName}'.`);
            }
            filter.comparand = filter.comparand.toLowerCase();
            if (filter.comparand !== "true" && filter.comparand !== "false") {
                throw new UnexpectedFilterCreateError(`The comparand '${filter.comparand}' is not a valid boolean value for the fieldName Success.`);
            }
        }
    }
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
class CollectionConfigurationErrorTracker {
    constructor() {
        /**
         * This list represents the errors that are found when the response from a ping or post is initially parsed.
         * The errors in this list are expected to stay the same across multiple post requests of the same configuration
         * id, and so will only be changed when a new configuration gets parsed.
         */
        this.validationTimeErrors = [];
        /**
         * This list represents errors that can't be caught while parsing the response - such as validation errors that would occur when
         * analyzing customDimensions present in incoming spans/logs, or when creating a projection. These errors aren't expected to be the
         * same across post requests of the same configuration id and so is expected to be regenerated for every post request.
         */
        this.runTimeErrors = [];
        this.validationTimeErrors = [];
        this.runTimeErrors = [];
    }
    addValidationError(error) {
        this.validationTimeErrors.push(error);
    }
    addRunTimeError(error) {
        this.runTimeErrors.push(error);
    }
    getErrors() {
        return this.validationTimeErrors.concat(this.runTimeErrors);
    }
    clearRunTimeErrors() {
        this.runTimeErrors = [];
    }
    clearValidationTimeErrors() {
        this.validationTimeErrors = [];
    }
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
class Projection {
    constructor() {
        this.projectionMap = new Map();
        this.avgMap = new Map();
    }
    // This method is intended to be called upon configuration change for every valid derivedMetricInfo.
    initDerivedMetricProjection(derivedMetricInfo) {
        if (derivedMetricInfo.aggregation === KnownAggregationType.Min.toString()) {
            // set to max value so that the value from the first telemetry item will always be less than it
            this.projectionMap.set(derivedMetricInfo.id, [Number.MAX_VALUE, KnownAggregationType.Min]);
        }
        else if (derivedMetricInfo.aggregation === KnownAggregationType.Max.toString()) {
            // set to min value so that the value from the first telemetry item will always be more than it
            this.projectionMap.set(derivedMetricInfo.id, [Number.MIN_VALUE, KnownAggregationType.Max]);
        }
        else if (derivedMetricInfo.aggregation === KnownAggregationType.Sum.toString()) {
            this.projectionMap.set(derivedMetricInfo.id, [0, KnownAggregationType.Sum]);
        }
        else {
            this.projectionMap.set(derivedMetricInfo.id, [0, KnownAggregationType.Avg]);
            this.avgMap.set(derivedMetricInfo.id, [0, 0]);
        }
    }
    calculateProjection(derivedMetricInfo, data) {
        let incrementBy;
        if (derivedMetricInfo.projection === "Count()") {
            incrementBy = 1;
        }
        else if (derivedMetricInfo.projection === "Duration") {
            if (isRequestData(data) || isDependencyData(data)) {
                incrementBy = data.Duration;
            }
            else {
                throw new MetricFailureToCreateError("The projection Duration is not supported for the telemetry type Exception or Trace.");
            }
        }
        else if (derivedMetricInfo.projection.startsWith("CustomDimensions.")) {
            const customDimKey = derivedMetricInfo.projection.replace("CustomDimensions.", "");
            let customDimValue;
            if (data.CustomDimensions.has(customDimKey)) {
                const parsedValue = parseFloat(data.CustomDimensions.get(customDimKey));
                if (isNaN(parsedValue)) {
                    throw new MetricFailureToCreateError(`Could not calculate the projection because the custom dimension value '${data.CustomDimensions.get(customDimKey)}' for the dimension '${customDimKey}' is not a valid number.`);
                }
                else {
                    customDimValue = parsedValue;
                }
            }
            else {
                throw new MetricFailureToCreateError(`Could not calculate the projection because the custom dimension '${customDimKey}' was not found in the telemetry data.`);
            }
            incrementBy = customDimValue;
        }
        else {
            throw new MetricFailureToCreateError(`The projection '${derivedMetricInfo.projection}' is not supported in this SDK.`);
        }
        const projection = this.calculateAggregation(derivedMetricInfo.aggregation, derivedMetricInfo.id, incrementBy);
        this.projectionMap.set(derivedMetricInfo.id, [projection, derivedMetricInfo.aggregation]);
    }
    // This method is intended to be called every second when export() is called.
    getMetricValues() {
        const result = new Map();
        for (const [key, value] of this.projectionMap.entries()) {
            let projection;
            if (value[1] === KnownAggregationType.Min.toString()) {
                projection = value[0] === Number.MAX_VALUE ? 0 : value[0];
                value[0] = Number.MAX_VALUE; // reset for next 1s interval
            }
            else if (value[1] === KnownAggregationType.Max.toString()) {
                projection = value[0] === Number.MIN_VALUE ? 0 : value[0];
                value[0] = Number.MIN_VALUE; // reset for next 1s interval
            }
            else {
                projection = value[0];
                value[0] = 0; // reset for next 1s interval
                if (value[1] === KnownAggregationType.Avg.toString()) {
                    this.avgMap.set(key, [0, 0]); // reset for next 1s interval
                }
            }
            result.set(key, projection);
        }
        return result;
    }
    // This method is intended to be called after upon config change or when we return to ping.
    clearProjectionMaps() {
        this.projectionMap.clear();
        this.avgMap.clear();
    }
    calculateAggregation(aggregation, id, incrementBy) {
        const prevValue = this.projectionMap.get(id)[0];
        switch (aggregation) {
            case KnownAggregationType.Sum.toString():
                return prevValue + incrementBy;
            case KnownAggregationType.Min.toString():
                return Math.min(prevValue, incrementBy);
            case KnownAggregationType.Max.toString():
                return Math.max(prevValue, incrementBy);
            case KnownAggregationType.Avg.toString(): {
                const [prevSum, prevCount] = this.avgMap.get(id);
                this.avgMap.set(id, [prevSum + incrementBy, prevCount + 1]);
                return (prevSum + incrementBy) / (prevCount + 1);
            }
            default:
                throw new MetricFailureToCreateError(`The aggregation '${aggregation}' is not supported in this SDK.`);
        }
    }
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
const POST_INTERVAL = 1000;
const MAX_POST_WAIT_TIME = 20000;
const PING_INTERVAL = 5000;
const MAX_PING_WAIT_TIME = 60000;
const FALLBACK_INTERVAL = 60000;
/**
 * Azure Monitor Live Metrics
 * @internal
 */
class LiveMetrics {
    /**
     * Initializes a new instance of the StandardMetrics class.
     * @param config - Distro configuration.
     * @param options - Standard Metrics options.
     */
    constructor(config) {
        this.documents = [];
        this.lastSuccessTime = Date.now();
        this.totalRequestCount = 0;
        this.totalFailedRequestCount = 0;
        this.totalDependencyCount = 0;
        this.totalFailedDependencyCount = 0;
        this.totalExceptionCount = 0;
        this.requestDuration = 0;
        this.dependencyDuration = 0;
        this.lastRequestDuration = {
            count: 0,
            duration: 0,
            time: 0,
        };
        this.lastRequestRate = { count: 0, time: 0 };
        this.lastFailedRequestRate = { count: 0, time: 0 };
        this.lastDependencyDuration = {
            count: 0,
            duration: 0,
            time: 0,
        };
        this.lastDependencyRate = { count: 0, time: 0 };
        this.lastFailedDependencyRate = { count: 0, time: 0 };
        this.lastExceptionRate = { count: 0, time: 0 };
        this.statsbeatOptionsUpdated = false;
        this.etag = "";
        this.errorTracker = new CollectionConfigurationErrorTracker();
        // For tracking of duplicate metric ids in the same configuration.
        this.seenMetricIds = new Set();
        this.validDerivedMetrics = new Map();
        this.derivedMetricProjection = new Projection();
        this.validator = new Validator();
        this.filter = new Filter();
        // type: Map<telemetryType, Map<id, FilterConjunctionGroupInfo[]>>
        this.validDocumentFilterConjuctionGroupInfos = new Map();
        this.config = config;
        const idGenerator = new sdkTraceBase.RandomIdGenerator();
        const streamId = idGenerator.generateTraceId();
        const machineName = os__namespace.hostname();
        const instance = getCloudRoleInstance(this.config.resource);
        const roleName = getCloudRole(this.config.resource);
        const version = getSdkVersion();
        this.baseMonitoringDataPoint = {
            version: version,
            invariantVersion: 5, // 5 means we support live metrics filtering of metrics and documents
            instance: instance,
            roleName: roleName,
            machineName: machineName,
            streamId: streamId,
            performanceCollectionSupported: true,
            isWebApp: process.env["WEBSITE_SITE_NAME"] ? true : false,
        };
        const parsedConnectionString = ConnectionStringParser.parse(this.config.azureMonitorExporterOptions.connectionString ||
            process.env["APPLICATIONINSIGHTS_CONNECTION_STRING"]);
        this.pingSender = new QuickpulseSender({
            endpointUrl: parsedConnectionString.liveendpoint || DEFAULT_LIVEMETRICS_ENDPOINT,
            instrumentationKey: parsedConnectionString.instrumentationkey || "",
            credential: this.config.azureMonitorExporterOptions.credential,
            credentialScopes: parsedConnectionString.aadaudience ||
                this.config.azureMonitorExporterOptions.credentialScopes,
        });
        const exporterOptions = {
            endpointUrl: parsedConnectionString.liveendpoint || DEFAULT_LIVEMETRICS_ENDPOINT,
            instrumentationKey: parsedConnectionString.instrumentationkey || "",
            credential: this.config.azureMonitorExporterOptions.credential,
            credentialScopes: parsedConnectionString.aadaudience ||
                this.config.azureMonitorExporterOptions.credentialScopes,
            // eslint-disable-next-line @typescript-eslint/no-misused-promises
            postCallback: this.quickPulseDone.bind(this),
            getDocumentsFn: this.getDocuments.bind(this),
            getErrorsFn: this.getErrors.bind(this),
            getDerivedMetricValuesFn: this.getDerivedMetricValues.bind(this),
            baseMonitoringDataPoint: this.baseMonitoringDataPoint,
        };
        this.quickpulseExporter = new QuickpulseMetricExporter(exporterOptions);
        this.isCollectingData = false;
        this.pingInterval = PING_INTERVAL; // Default
        this.postInterval = POST_INTERVAL;
        // eslint-disable-next-line @typescript-eslint/no-misused-promises
        this.handle = setTimeout(this.goQuickpulse.bind(this), this.pingInterval);
        this.handle.unref(); // Don't block apps from terminating
        this.lastCpuUsage = process.cpuUsage();
        this.lastHrTime = process.hrtime.bigint();
    }
    shutdown() {
        var _a;
        (_a = this.meterProvider) === null || _a === void 0 ? void 0 : _a.shutdown();
    }
    async goQuickpulse() {
        if (!this.isCollectingData) {
            // If not collecting, Ping
            try {
                const params = {
                    transmissionTime: getTransmissionTime(),
                    monitoringDataPoint: this.baseMonitoringDataPoint,
                    configurationEtag: this.etag,
                };
                await api.context.with(core.suppressTracing(api.context.active()), async () => {
                    const response = await this.pingSender.isSubscribed(params);
                    this.quickPulseDone(response);
                });
            }
            catch (error) {
                this.quickPulseDone(undefined);
            }
            // eslint-disable-next-line @typescript-eslint/no-misused-promises
            this.handle = setTimeout(this.goQuickpulse.bind(this), this.pingInterval);
            this.handle.unref();
        }
        if (this.isCollectingData) {
            this.activateMetrics({ collectionInterval: this.postInterval });
        }
    }
    // eslint-disable-next-line @typescript-eslint/require-await
    async quickPulseDone(response) {
        if (!response) {
            if (!this.isCollectingData) {
                if (Date.now() - this.lastSuccessTime >= MAX_PING_WAIT_TIME) {
                    this.pingInterval = FALLBACK_INTERVAL;
                }
            }
            else {
                if (Date.now() - this.lastSuccessTime >= MAX_POST_WAIT_TIME) {
                    this.postInterval = FALLBACK_INTERVAL;
                    this.deactivateMetrics();
                    this.activateMetrics({ collectionInterval: this.postInterval });
                }
            }
        }
        else {
            this.postInterval = POST_INTERVAL;
            // Update using response if needed
            this.lastSuccessTime = Date.now();
            this.isCollectingData =
                response.xMsQpsSubscribed && response.xMsQpsSubscribed === "true" ? true : false;
            if (response.xMsQpsConfigurationEtag && this.etag !== response.xMsQpsConfigurationEtag) {
                this.updateConfiguration(response);
            }
            // If collecting was stoped
            if (!this.isCollectingData && this.meterProvider) {
                this.etag = "";
                this.deactivateMetrics();
                // eslint-disable-next-line @typescript-eslint/no-misused-promises
                this.handle = setTimeout(this.goQuickpulse.bind(this), this.pingInterval);
                this.handle.unref();
            }
            const endpointRedirect = response.xMsQpsServiceEndpointRedirectV2;
            if (endpointRedirect) {
                this.pingSender.handlePermanentRedirect(endpointRedirect);
                this.quickpulseExporter.getSender().handlePermanentRedirect(endpointRedirect);
            }
            const pollingInterval = response.xMsQpsServicePollingIntervalHint;
            if (pollingInterval) {
                this.pingInterval = Number(pollingInterval);
            }
            else {
                this.pingInterval = PING_INTERVAL;
            }
        }
    }
    // Activate live metrics collection
    activateMetrics(options) {
        if (this.meterProvider) {
            return;
        }
        // Turn on live metrics active collection for statsbeat
        if (!this.statsbeatOptionsUpdated) {
            getInstance().setStatsbeatFeatures({}, { liveMetrics: true });
            this.statsbeatOptionsUpdated = true;
        }
        this.totalDependencyCount = 0;
        this.totalExceptionCount = 0;
        this.totalFailedDependencyCount = 0;
        this.totalFailedRequestCount = 0;
        this.totalRequestCount = 0;
        this.requestDuration = 0;
        this.dependencyDuration = 0;
        this.lastRequestDuration = { count: 0, duration: 0, time: 0 };
        this.lastRequestRate = { count: 0, time: 0 };
        this.lastFailedRequestRate = { count: 0, time: 0 };
        this.lastDependencyDuration = { count: 0, duration: 0, time: 0 };
        this.lastDependencyRate = { count: 0, time: 0 };
        this.lastFailedDependencyRate = { count: 0, time: 0 };
        this.lastExceptionRate = { count: 0, time: 0 };
        const metricReaderOptions = {
            exporter: this.quickpulseExporter,
            exportIntervalMillis: options === null || options === void 0 ? void 0 : options.collectionInterval,
        };
        this.metricReader = new sdkMetrics.PeriodicExportingMetricReader(metricReaderOptions);
        const meterProviderConfig = {
            resource: this.config.resource,
            readers: [this.metricReader],
        };
        this.meterProvider = new sdkMetrics.MeterProvider(meterProviderConfig);
        this.meter = this.meterProvider.getMeter("AzureMonitorLiveMetricsMeter");
        this.requestDurationGauge = this.meter.createObservableGauge(QuickPulseOpenTelemetryMetricNames.REQUEST_DURATION, {
            valueType: api.ValueType.DOUBLE,
        });
        this.requestRateGauge = this.meter.createObservableGauge(QuickPulseOpenTelemetryMetricNames.REQUEST_RATE, {
            valueType: api.ValueType.DOUBLE,
        });
        this.requestFailedRateGauge = this.meter.createObservableGauge(QuickPulseOpenTelemetryMetricNames.REQUEST_FAILURE_RATE, {
            valueType: api.ValueType.DOUBLE,
        });
        this.dependencyDurationGauge = this.meter.createObservableGauge(QuickPulseOpenTelemetryMetricNames.DEPENDENCY_DURATION, {
            valueType: api.ValueType.DOUBLE,
        });
        this.dependencyRateGauge = this.meter.createObservableGauge(QuickPulseOpenTelemetryMetricNames.DEPENDENCY_RATE, {
            valueType: api.ValueType.DOUBLE,
        });
        this.dependencyFailedRateGauge = this.meter.createObservableGauge(QuickPulseOpenTelemetryMetricNames.DEPENDENCY_FAILURE_RATE, {
            valueType: api.ValueType.DOUBLE,
        });
        this.processPhysicalBytesGauge = this.meter.createObservableGauge(QuickPulseOpenTelemetryMetricNames.PHYSICAL_BYTES, {
            valueType: api.ValueType.INT,
        });
        this.percentProcessorTimeNormalizedGauge = this.meter.createObservableGauge(QuickPulseOpenTelemetryMetricNames.PROCESSOR_TIME_NORMALIZED, {
            valueType: api.ValueType.DOUBLE,
        });
        this.exceptionsRateGauge = this.meter.createObservableGauge(QuickPulseOpenTelemetryMetricNames.EXCEPTION_RATE, {
            valueType: api.ValueType.DOUBLE,
        });
        this.requestDurationGauge.addCallback(this.getRequestDuration.bind(this));
        this.requestRateGauge.addCallback(this.getRequestRate.bind(this));
        this.requestFailedRateGauge.addCallback(this.getRequestFailedRate.bind(this));
        this.dependencyDurationGauge.addCallback(this.getDependencyDuration.bind(this));
        this.dependencyRateGauge.addCallback(this.getDependencyRate.bind(this));
        this.dependencyFailedRateGauge.addCallback(this.getDependencyFailedRate.bind(this));
        this.exceptionsRateGauge.addCallback(this.getExceptionRate.bind(this));
        this.processPhysicalBytesGauge.addCallback(this.getPhysicalMemory.bind(this));
        this.percentProcessorTimeNormalizedGauge.addCallback(this.getProcessorTimeNormalized.bind(this));
    }
    /**
     * Deactivate metric collection
     */
    deactivateMetrics() {
        var _a;
        this.documents = [];
        this.validDocumentFilterConjuctionGroupInfos.clear();
        this.errorTracker.clearRunTimeErrors();
        this.errorTracker.clearValidationTimeErrors();
        this.validDerivedMetrics.clear();
        this.derivedMetricProjection.clearProjectionMaps();
        this.seenMetricIds.clear();
        (_a = this.meterProvider) === null || _a === void 0 ? void 0 : _a.shutdown();
        this.meterProvider = undefined;
    }
    /**
     * Force flush Meter Provider.
     */
    async flush() {
        var _a;
        await ((_a = this.meterProvider) === null || _a === void 0 ? void 0 : _a.forceFlush());
    }
    /**
     *Get OpenTelemetry MeterProvider
     */
    getMeterProvider() {
        return this.meterProvider;
    }
    getDocuments() {
        const result = this.documents;
        this.documents = [];
        return result;
    }
    getErrors() {
        const result = this.errorTracker.getErrors();
        this.errorTracker.clearRunTimeErrors();
        return result;
    }
    getDerivedMetricValues() {
        return this.derivedMetricProjection.getMetricValues();
    }
    addDocument(document) {
        if (document) {
            // Limit risk of memory leak by limiting doc length to something manageable
            if (this.documents.length > 20) {
                this.documents.shift(); // Remove oldest document
            }
            this.documents.push(document);
        }
    }
    /**
     * Record Span metrics
     * @internal
     */
    recordSpan(span) {
        if (this.isCollectingData) {
            const columns = getSpanData(span);
            let documentConfiguration;
            let derivedMetricInfos;
            if (isRequestData(columns)) {
                documentConfiguration =
                    this.validDocumentFilterConjuctionGroupInfos.get(KnownTelemetryType.Request) ||
                        new Map();
                derivedMetricInfos = this.validDerivedMetrics.get(KnownTelemetryType.Request) || [];
            }
            else {
                documentConfiguration =
                    this.validDocumentFilterConjuctionGroupInfos.get(KnownTelemetryType.Dependency) ||
                        new Map();
                derivedMetricInfos = this.validDerivedMetrics.get(KnownTelemetryType.Dependency) || [];
            }
            this.applyDocumentFilters(documentConfiguration, columns);
            this.checkMetricFilterAndCreateProjection(derivedMetricInfos, columns);
            const durationMs = core.hrTimeToMilliseconds(span.duration);
            const success = span.status.code !== api.SpanStatusCode.ERROR;
            if (span.kind === api.SpanKind.SERVER || span.kind === api.SpanKind.CONSUMER) {
                this.totalRequestCount++;
                this.requestDuration += durationMs;
                if (!success) {
                    this.totalFailedRequestCount++;
                }
            }
            else {
                this.totalDependencyCount++;
                this.dependencyDuration += durationMs;
                if (!success) {
                    this.totalFailedDependencyCount++;
                }
            }
            if (span.events) {
                span.events.forEach((event) => {
                    event.attributes = event.attributes || {};
                    if (event.name === "exception") {
                        const exceptionColumns = getSpanExceptionColumns(event.attributes, span.attributes);
                        documentConfiguration =
                            this.validDocumentFilterConjuctionGroupInfos.get(KnownTelemetryType.Exception) ||
                                new Map();
                        this.applyDocumentFilters(documentConfiguration, exceptionColumns, event.attributes[semanticConventions.SEMATTRS_EXCEPTION_TYPE]);
                        derivedMetricInfos = this.validDerivedMetrics.get(KnownTelemetryType.Exception) || [];
                        this.checkMetricFilterAndCreateProjection(derivedMetricInfos, exceptionColumns);
                        this.totalExceptionCount++;
                    }
                });
            }
        }
    }
    /**
     * Record LogRecord metrics, add attribute so data is not aggregated again in ingestion
     * @internal
     */
    recordLog(logRecord) {
        if (this.isCollectingData) {
            const columns = getLogData(logRecord);
            let derivedMetricInfos;
            let documentConfiguration;
            if (isExceptionData(columns)) {
                documentConfiguration =
                    this.validDocumentFilterConjuctionGroupInfos.get(KnownTelemetryType.Exception) ||
                        new Map();
                this.applyDocumentFilters(documentConfiguration, columns, logRecord.attributes[semanticConventions.SEMATTRS_EXCEPTION_TYPE]);
                derivedMetricInfos = this.validDerivedMetrics.get(KnownTelemetryType.Exception) || [];
                this.totalExceptionCount++;
            }
            else {
                // trace
                documentConfiguration =
                    this.validDocumentFilterConjuctionGroupInfos.get(KnownTelemetryType.Trace) ||
                        new Map();
                this.applyDocumentFilters(documentConfiguration, columns);
                derivedMetricInfos = this.validDerivedMetrics.get(KnownTelemetryType.Trace) || [];
            }
            this.checkMetricFilterAndCreateProjection(derivedMetricInfos, columns);
        }
    }
    getRequestDuration(observableResult) {
        const currentTime = +new Date();
        const requestInterval = this.totalRequestCount - this.lastRequestDuration.count || 0;
        const durationInterval = this.requestDuration - this.lastRequestDuration.duration || 0;
        const elapsedMs = currentTime - this.lastRequestDuration.time;
        if (elapsedMs > 0) {
            const averageExecutionTime = durationInterval / requestInterval || 0; // default to 0 in case no requests in this interval
            observableResult.observe(averageExecutionTime);
        }
        this.lastRequestDuration = {
            count: this.totalRequestCount,
            duration: this.requestDuration,
            time: currentTime,
        };
    }
    getRequestRate(observableResult) {
        const currentTime = +new Date();
        const intervalRequests = this.totalRequestCount - this.lastRequestRate.count || 0;
        const elapsedMs = currentTime - this.lastRequestRate.time;
        if (elapsedMs > 0) {
            const elapsedSeconds = elapsedMs / 1000;
            const dataPerSec = intervalRequests / elapsedSeconds;
            observableResult.observe(dataPerSec);
        }
        this.lastRequestRate = {
            count: this.totalRequestCount,
            time: currentTime,
        };
    }
    getRequestFailedRate(observableResult) {
        const currentTime = +new Date();
        const intervalRequests = this.totalFailedRequestCount - this.lastFailedRequestRate.count || 0;
        const elapsedMs = currentTime - this.lastFailedRequestRate.time;
        if (elapsedMs > 0) {
            const elapsedSeconds = elapsedMs / 1000;
            const dataPerSec = intervalRequests / elapsedSeconds;
            observableResult.observe(dataPerSec);
        }
        this.lastFailedRequestRate = {
            count: this.totalFailedRequestCount,
            time: currentTime,
        };
    }
    getDependencyDuration(observableResult) {
        const currentTime = +new Date();
        const dependencyInterval = this.totalDependencyCount - this.lastDependencyDuration.count || 0;
        const durationInterval = this.dependencyDuration - this.lastDependencyDuration.duration || 0;
        const elapsedMs = currentTime - this.lastDependencyDuration.time;
        if (elapsedMs > 0) {
            const averageExecutionTime = durationInterval / dependencyInterval || 0; // default to 0 in case no dependencies in this interval
            observableResult.observe(averageExecutionTime);
        }
        this.lastDependencyDuration = {
            count: this.totalDependencyCount,
            duration: this.dependencyDuration,
            time: currentTime,
        };
    }
    getDependencyRate(observableResult) {
        const currentTime = +new Date();
        const intervalData = this.totalDependencyCount - this.lastDependencyRate.count || 0;
        const elapsedMs = currentTime - this.lastDependencyRate.time;
        if (elapsedMs > 0) {
            const elapsedSeconds = elapsedMs / 1000;
            const dataPerSec = intervalData / elapsedSeconds;
            observableResult.observe(dataPerSec);
        }
        this.lastDependencyRate = {
            count: this.totalDependencyCount,
            time: currentTime,
        };
    }
    getDependencyFailedRate(observableResult) {
        const currentTime = +new Date();
        const intervalData = this.totalFailedDependencyCount - this.lastFailedDependencyRate.count || 0;
        const elapsedMs = currentTime - this.lastFailedDependencyRate.time;
        if (elapsedMs > 0) {
            const elapsedSeconds = elapsedMs / 1000;
            const dataPerSec = intervalData / elapsedSeconds;
            observableResult.observe(dataPerSec);
        }
        this.lastFailedDependencyRate = {
            count: this.totalFailedDependencyCount,
            time: currentTime,
        };
    }
    getExceptionRate(observableResult) {
        const currentTime = +new Date();
        const intervalData = this.totalExceptionCount - this.lastExceptionRate.count || 0;
        const elapsedMs = currentTime - this.lastExceptionRate.time;
        if (elapsedMs > 0) {
            const elapsedSeconds = elapsedMs / 1000;
            const dataPerSec = intervalData / elapsedSeconds;
            observableResult.observe(dataPerSec);
        }
        this.lastExceptionRate = {
            count: this.totalExceptionCount,
            time: currentTime,
        };
    }
    getPhysicalMemory(observableResult) {
        const rss = getPhysicalMemory();
        observableResult.observe(rss);
    }
    getProcessorTimeNormalized(observableResult) {
        const cpuUsagePercent = getProcessorTimeNormalized(this.lastHrTime, this.lastCpuUsage);
        observableResult.observe(cpuUsagePercent);
        this.lastHrTime = process.hrtime.bigint();
        this.lastCpuUsage = process.cpuUsage();
    }
    updateConfiguration(response) {
        this.etag = response.xMsQpsConfigurationEtag || "";
        this.quickpulseExporter.setEtag(this.etag);
        this.errorTracker.clearValidationTimeErrors();
        this.validDocumentFilterConjuctionGroupInfos.clear();
        this.validDerivedMetrics.clear();
        this.derivedMetricProjection.clearProjectionMaps();
        this.seenMetricIds.clear();
        this.parseDocumentFilterConfiguration(response);
        this.parseMetricFilterConfiguration(response);
    }
    parseDocumentFilterConfiguration(response) {
        response.documentStreams.forEach((documentStreamInfo) => {
            documentStreamInfo.documentFilterGroups.forEach((documentFilterGroupInfo) => {
                var _a;
                try {
                    this.validator.validateTelemetryType(documentFilterGroupInfo.telemetryType);
                    this.validator.validateDocumentFilters(documentFilterGroupInfo);
                    this.filter.renameExceptionFieldNamesForFiltering(documentFilterGroupInfo.filters);
                    if (!this.validDocumentFilterConjuctionGroupInfos.has(documentFilterGroupInfo.telemetryType)) {
                        this.validDocumentFilterConjuctionGroupInfos.set(documentFilterGroupInfo.telemetryType, new Map());
                    }
                    const innerMap = this.validDocumentFilterConjuctionGroupInfos.get(documentFilterGroupInfo.telemetryType);
                    if (!(innerMap === null || innerMap === void 0 ? void 0 : innerMap.has(documentStreamInfo.id))) {
                        innerMap === null || innerMap === void 0 ? void 0 : innerMap.set(documentStreamInfo.id, [documentFilterGroupInfo.filters]);
                    }
                    else {
                        (_a = innerMap.get(documentStreamInfo.id)) === null || _a === void 0 ? void 0 : _a.push(documentFilterGroupInfo.filters);
                    }
                }
                catch (error) {
                    const configError = {
                        collectionConfigurationErrorType: "",
                        message: "",
                        fullException: "",
                        data: [],
                    };
                    if (error instanceof TelemetryTypeError) {
                        configError.collectionConfigurationErrorType = "DocumentTelemetryTypeUnsupported";
                    }
                    else if (error instanceof UnexpectedFilterCreateError) {
                        configError.collectionConfigurationErrorType =
                            KnownCollectionConfigurationErrorType.DocumentStreamFailureToCreateFilterUnexpected;
                    }
                    if (error instanceof Error) {
                        configError.message = error.message;
                        configError.fullException = error.stack || "";
                    }
                    const data = [];
                    data.push({ key: "DocumentStreamInfoId", value: documentStreamInfo.id });
                    data.push({ key: "ETag", value: this.etag });
                    configError.data = data;
                    this.errorTracker.addValidationError(configError);
                }
            });
        });
    }
    applyDocumentFilters(documentConfiguration, data, exceptionType) {
        const streamIds = new Set();
        documentConfiguration.forEach((filterConjunctionGroupInfoList, streamId) => {
            filterConjunctionGroupInfoList.forEach((filterConjunctionGroupInfo) => {
                // by going though each filterConjuctionGroupInfo, we are implicitly -OR-ing
                // different filterConjunctionGroupInfo within documentStreamInfo. If there are multiple
                // documentStreamInfos, this logic will -OR- the filtering results of each documentStreamInfo.
                if (this.filter.checkFilterConjunctionGroup(filterConjunctionGroupInfo, data)) {
                    streamIds.add(streamId);
                }
            });
        });
        // Emit a document when a telemetry data matches a particular filtering configuration,
        // or when filtering configuration is empty.
        if (streamIds.size > 0 || documentConfiguration.size === 0) {
            let document;
            if (isRequestData(data) || isDependencyData(data)) {
                document = getSpanDocument(data);
            }
            else if (isExceptionData(data) && exceptionType) {
                document = getLogDocument(data, exceptionType);
            }
            else {
                document = getLogDocument(data);
            }
            document.documentStreamIds = [...streamIds];
            this.addDocument(document);
        }
    }
    parseMetricFilterConfiguration(response) {
        response.metrics.forEach((derivedMetricInfo) => {
            var _a;
            try {
                if (!this.seenMetricIds.has(derivedMetricInfo.id)) {
                    this.seenMetricIds.add(derivedMetricInfo.id);
                    this.validator.validateTelemetryType(derivedMetricInfo.telemetryType);
                    this.validator.checkCustomMetricProjection(derivedMetricInfo);
                    this.validator.validateMetricFilters(derivedMetricInfo);
                    derivedMetricInfo.filterGroups.forEach((filterConjunctionGroupInfo) => {
                        this.filter.renameExceptionFieldNamesForFiltering(filterConjunctionGroupInfo);
                    });
                    if (this.validDerivedMetrics.has(derivedMetricInfo.telemetryType)) {
                        (_a = this.validDerivedMetrics.get(derivedMetricInfo.telemetryType)) === null || _a === void 0 ? void 0 : _a.push(derivedMetricInfo);
                    }
                    else {
                        this.validDerivedMetrics.set(derivedMetricInfo.telemetryType, [derivedMetricInfo]);
                    }
                }
                else {
                    throw new DuplicateMetricIdError(`Duplicate Metric Id: ${derivedMetricInfo.id}`);
                }
                this.derivedMetricProjection.initDerivedMetricProjection(derivedMetricInfo);
            }
            catch (error) {
                const configError = {
                    collectionConfigurationErrorType: "",
                    message: "",
                    fullException: "",
                    data: [],
                };
                if (error instanceof TelemetryTypeError) {
                    configError.collectionConfigurationErrorType =
                        KnownCollectionConfigurationErrorType.MetricTelemetryTypeUnsupported;
                }
                else if (error instanceof UnexpectedFilterCreateError) {
                    configError.collectionConfigurationErrorType =
                        KnownCollectionConfigurationErrorType.MetricFailureToCreateFilterUnexpected;
                }
                else if (error instanceof DuplicateMetricIdError) {
                    configError.collectionConfigurationErrorType =
                        KnownCollectionConfigurationErrorType.MetricDuplicateIds;
                }
                if (error instanceof Error) {
                    configError.message = error.message;
                    configError.fullException = error.stack || "";
                }
                const data = [];
                data.push({ key: "MetricId", value: derivedMetricInfo.id });
                data.push({ key: "ETag", value: this.etag });
                configError.data = data;
                this.errorTracker.addValidationError(configError);
            }
        });
    }
    checkMetricFilterAndCreateProjection(derivedMetricInfoList, data) {
        derivedMetricInfoList.forEach((derivedMetricInfo) => {
            if (this.filter.checkMetricFilters(derivedMetricInfo, data)) {
                try {
                    this.derivedMetricProjection.calculateProjection(derivedMetricInfo, data);
                }
                catch (error) {
                    const configError = {
                        collectionConfigurationErrorType: "",
                        message: "",
                        fullException: "",
                        data: [],
                    };
                    if (error instanceof MetricFailureToCreateError) {
                        configError.collectionConfigurationErrorType =
                            KnownCollectionConfigurationErrorType.MetricFailureToCreate;
                        if (error instanceof Error) {
                            configError.message = error.message;
                            configError.fullException = error.stack || "";
                        }
                        const errorData = [];
                        errorData.push({ key: "MetricId", value: derivedMetricInfo.id });
                        errorData.push({ key: "ETag", value: this.etag });
                        configError.data = errorData;
                        this.errorTracker.addRunTimeError(configError);
                    }
                }
            }
        });
    }
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * Azure Monitor OpenTelemetry Metric Handler
 */
class MetricHandler {
    /**
     * Initializes a new instance of the MetricHandler class.
     * @param config - Distro configuration.
     * @param options - Metric Handler options.
     */
    constructor(config, options) {
        var _a, _b, _c, _d, _e, _f, _g;
        this._collectionInterval = 60000; // 60 seconds
        this._config = config;
        // Adding Views of instrumentations will allow customer to add Metric Readers after, and get access to previously created metrics using the views shared state
        this._views = [];
        if ((_a = config.instrumentationOptions.azureSdk) === null || _a === void 0 ? void 0 : _a.enabled) {
            this._views.push(new sdkMetrics.View({ meterName: "@azure/opentelemetry-instrumentation-azure-sdk" }));
        }
        if ((_b = config.instrumentationOptions.http) === null || _b === void 0 ? void 0 : _b.enabled) {
            this._views.push(new sdkMetrics.View({ meterName: "@azure/opentelemetry-instrumentation-http" }));
        }
        if ((_c = config.instrumentationOptions.mongoDb) === null || _c === void 0 ? void 0 : _c.enabled) {
            this._views.push(new sdkMetrics.View({ meterName: "@azure/opentelemetry-instrumentation-mongodb" }));
        }
        if ((_d = config.instrumentationOptions.mySql) === null || _d === void 0 ? void 0 : _d.enabled) {
            this._views.push(new sdkMetrics.View({ meterName: "@opentelemetry/instrumentation-mysql" }));
        }
        if ((_e = config.instrumentationOptions.postgreSql) === null || _e === void 0 ? void 0 : _e.enabled) {
            this._views.push(new sdkMetrics.View({ meterName: "@opentelemetry/instrumentation-pg" }));
        }
        if ((_f = config.instrumentationOptions.redis4) === null || _f === void 0 ? void 0 : _f.enabled) {
            this._views.push(new sdkMetrics.View({ meterName: "@opentelemetry/instrumentation-redis-4" }));
        }
        if ((_g = config.instrumentationOptions.redis) === null || _g === void 0 ? void 0 : _g.enabled) {
            this._views.push(new sdkMetrics.View({ meterName: "@azure/opentelemetry-instrumentation-redis" }));
        }
        this._azureExporter = new monitorOpentelemetryExporter.AzureMonitorMetricExporter(this._config.azureMonitorExporterOptions);
        const metricReaderOptions = {
            exporter: this._azureExporter,
            exportIntervalMillis: (options === null || options === void 0 ? void 0 : options.collectionInterval) || this._collectionInterval,
        };
        this._metricReader = new sdkMetrics.PeriodicExportingMetricReader(metricReaderOptions);
        if (this._config.enableStandardMetrics &&
            !process.env[APPLICATION_INSIGHTS_NO_STANDARD_METRICS]) {
            this._standardMetrics = new StandardMetrics(this._config);
        }
        if (this._config.enableLiveMetrics) {
            this._liveMetrics = new LiveMetrics(this._config);
        }
    }
    getMetricReader() {
        return this._metricReader;
    }
    getViews() {
        return this._views;
    }
    markSpanAsProcessed(span) {
        var _a;
        (_a = this._standardMetrics) === null || _a === void 0 ? void 0 : _a.markSpanAsProcessed(span);
    }
    recordSpan(span) {
        var _a, _b;
        (_a = this._standardMetrics) === null || _a === void 0 ? void 0 : _a.recordSpan(span);
        (_b = this._liveMetrics) === null || _b === void 0 ? void 0 : _b.recordSpan(span);
    }
    recordLog(logRecord) {
        var _a, _b;
        (_a = this._standardMetrics) === null || _a === void 0 ? void 0 : _a.recordLog(logRecord);
        (_b = this._liveMetrics) === null || _b === void 0 ? void 0 : _b.recordLog(logRecord);
    }
    /**
     * Shutdown handler
     */
    // eslint-disable-next-line @typescript-eslint/require-await
    async shutdown() {
        var _a, _b;
        (_a = this._standardMetrics) === null || _a === void 0 ? void 0 : _a.shutdown();
        (_b = this._liveMetrics) === null || _b === void 0 ? void 0 : _b.shutdown();
    }
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * Azure Monitor Span Processor.
 * @internal
 */
class AzureMonitorSpanProcessor {
    constructor(metricHandler) {
        this._metricHandler = metricHandler;
    }
    forceFlush() {
        return Promise.resolve();
    }
    onStart(span, _context) {
        this._metricHandler.markSpanAsProcessed(span);
    }
    onEnd(span) {
        try {
            this._metricHandler.recordSpan(span);
        }
        catch (error) {
            Logger.getInstance().warn("Error while recording span", error);
        }
    }
    shutdown() {
        return Promise.resolve();
    }
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
class AzureFunctionsHook {
    constructor() {
        try {
            // eslint-disable-next-line @typescript-eslint/no-require-imports
            this._functionsCoreModule = require("@azure/functions-core");
            this._addPreInvocationHook();
        }
        catch (error) {
            Logger.getInstance().debug("@azure/functions-core failed to load, not running in Azure Functions");
        }
    }
    shutdown() {
        if (this._preInvocationHook) {
            this._preInvocationHook.dispose();
            this._preInvocationHook = undefined;
        }
        this._functionsCoreModule = undefined;
    }
    _addPreInvocationHook() {
        if (!this._preInvocationHook) {
            this._preInvocationHook = this._functionsCoreModule.registerHook("preInvocation", 
            // eslint-disable-next-line @typescript-eslint/require-await
            async (preInvocationContext) => {
                const sharedContext = preInvocationContext.invocationContext;
                const traceContext = sharedContext.traceContext;
                // Update context to use Azure Functions one
                // eslint-disable-next-line @typescript-eslint/no-redundant-type-constituents
                let extractedContext = null;
                try {
                    if (traceContext) {
                        extractedContext = api.propagation.extract(api.context.active(), {
                            traceparent: traceContext.traceparent || traceContext.traceParent,
                            tracestate: traceContext.tracestate || traceContext.traceState,
                        });
                    }
                    const currentContext = extractedContext || api.context.active();
                    preInvocationContext.functionCallback = api.context.bind(currentContext, preInvocationContext.functionCallback);
                }
                catch (err) {
                    Logger.getInstance().error("Failed to propagate context in Azure Functions", err);
                }
            });
        }
    }
}

/**
 * ApplicationInsightsSampler is responsible for the following:
 * Implements same trace id hashing algorithm so that traces are sampled the same across multiple nodes
 * Adds item count to span attribute if span is sampled (needed for ingestion service)
 * @param samplingRatio - 0 to 1 value.
 */
class ApplicationInsightsSampler {
    /**
     * Initializes a new instance of the ApplicationInsightsSampler class.
     * @param samplingRatio - Value in the range [0,1], 1 meaning all data will sampled and 0 all Tracing data will be sampled out.
     */
    constructor(samplingRatio = 1) {
        this._samplingRatio = samplingRatio;
        if (this._samplingRatio > 1 ||
            this._samplingRatio < 0 ||
            !Number.isFinite(this._samplingRatio)) {
            api.diag.warn("Invalid sampling rate, sampling rate must be a value in the range [0,1].");
        }
        this._sampleRate = Math.round(this._samplingRatio * 100);
    }
    /**
     * Checks whether span needs to be created and tracked.
     *
     * @param context - Parent Context which may contain a span.
     * @param traceId - of the span to be created. It can be different from the
     *     traceId in the {@link SpanContext}. Typically in situations when the
     *     span to be created starts a new trace.
     * @param spanName - of the span to be created.
     * @param spanKind - of the span to be created.
     * @param attributes - Initial set of SpanAttributes for the Span being constructed.
     * @param links - Collection of links that will be associated with the Span to
     *     be created. Typically useful for batch operations.
     * @returns a {@link SamplingResult}.
     */
    shouldSample(
    // @ts-expect-error unused var
    context, traceId, 
    // @ts-expect-error unused var
    spanName, 
    // @ts-expect-error unused var
    spanKind, attributes, 
    // @ts-expect-error unused var
    links) {
        let isSampledIn = false;
        if (this._sampleRate === 100) {
            isSampledIn = true;
        }
        else if (this._sampleRate === 0) {
            isSampledIn = false;
        }
        else {
            isSampledIn = this._getSamplingHashCode(traceId) < this._sampleRate;
        }
        // Add sample rate as span attribute if it is not 100
        attributes = attributes || {};
        if (this._sampleRate !== 100) {
            attributes[AzureMonitorSampleRate] = this._sampleRate;
        }
        return isSampledIn
            ? { decision: sdkTraceBase.SamplingDecision.RECORD_AND_SAMPLED, attributes: attributes }
            : { decision: sdkTraceBase.SamplingDecision.RECORD, attributes: attributes };
    }
    /**
     * Return Sampler description
     */
    toString() {
        return `ApplicationInsightsSampler{${this._samplingRatio}}`;
    }
    _getSamplingHashCode(input) {
        const csharpMin = -2147483648;
        const csharpMax = 2147483647;
        let hash = 5381;
        if (!input) {
            return 0;
        }
        while (input.length < 8) {
            input = input + input;
        }
        for (let i = 0; i < input.length; i++) {
            // JS doesn't respond to integer overflow by wrapping around. Simulate it with bitwise operators ( | 0)
            hash = ((((hash << 5) + hash) | 0) + input.charCodeAt(i)) | 0;
        }
        hash = hash <= csharpMin ? csharpMax : Math.abs(hash);
        return (hash / csharpMax) * 100;
    }
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * Azure Monitor OpenTelemetry Trace Handler
 */
class TraceHandler {
    /**
     * Initializes a new instance of the TraceHandler class.
     * @param _config - Configuration.
     * @param _metricHandler - MetricHandler.
     */
    constructor(config, metricHandler) {
        this._config = config;
        this._metricHandler = metricHandler;
        this._instrumentations = [];
        this._aiSampler = new ApplicationInsightsSampler(this._config.samplingRatio);
        this._azureExporter = new monitorOpentelemetryExporter.AzureMonitorTraceExporter(this._config.azureMonitorExporterOptions);
        const bufferConfig = {
            maxExportBatchSize: 512,
            scheduledDelayMillis: 5000,
            exportTimeoutMillis: 30000,
            maxQueueSize: 2048,
        };
        this._batchSpanProcessor = new sdkTraceBase.BatchSpanProcessor(this._azureExporter, bufferConfig);
        this._azureSpanProcessor = new AzureMonitorSpanProcessor(this._metricHandler);
        this._azureFunctionsHook = new AzureFunctionsHook();
        this._initializeInstrumentations();
    }
    getSampler() {
        return this._aiSampler;
    }
    getBatchSpanProcessor() {
        return this._batchSpanProcessor;
    }
    getAzureMonitorSpanProcessor() {
        return this._azureSpanProcessor;
    }
    getInstrumentations() {
        return this._instrumentations;
    }
    /**
     * Shutdown handler
     */
    // eslint-disable-next-line @typescript-eslint/require-await
    async shutdown() {
        this._azureFunctionsHook.shutdown();
    }
    /**
     * Start auto collection of telemetry
     */
    _initializeInstrumentations() {
        var _a, _b, _c, _d, _e, _f, _g;
        if ((_a = this._config.instrumentationOptions.http) === null || _a === void 0 ? void 0 : _a.enabled) {
            const httpinstrumentationOptions = this._config.instrumentationOptions
                .http;
            const providedIgnoreOutgoingRequestHook = httpinstrumentationOptions.ignoreOutgoingRequestHook;
            const mergedIgnoreOutgoingRequestHook = (request) => {
                const result = ignoreOutgoingRequestHook(request);
                if (!result) {
                    // Not internal call
                    if (providedIgnoreOutgoingRequestHook) {
                        // Provided hook in config
                        return providedIgnoreOutgoingRequestHook(request);
                    }
                }
                return result;
            };
            httpinstrumentationOptions.ignoreOutgoingRequestHook = mergedIgnoreOutgoingRequestHook;
            this._instrumentations.push(new instrumentationHttp.HttpInstrumentation(this._config.instrumentationOptions.http));
        }
        if ((_b = this._config.instrumentationOptions.azureSdk) === null || _b === void 0 ? void 0 : _b.enabled) {
            this._instrumentations.push(opentelemetryInstrumentationAzureSdk.createAzureSdkInstrumentation(this._config.instrumentationOptions.azureSdk));
        }
        if ((_c = this._config.instrumentationOptions.mongoDb) === null || _c === void 0 ? void 0 : _c.enabled) {
            this._instrumentations.push(new instrumentationMongodb.MongoDBInstrumentation(this._config.instrumentationOptions.mongoDb));
        }
        if ((_d = this._config.instrumentationOptions.mySql) === null || _d === void 0 ? void 0 : _d.enabled) {
            this._instrumentations.push(new instrumentationMysql.MySQLInstrumentation(this._config.instrumentationOptions.mySql));
        }
        if ((_e = this._config.instrumentationOptions.postgreSql) === null || _e === void 0 ? void 0 : _e.enabled) {
            this._instrumentations.push(new instrumentationPg.PgInstrumentation(this._config.instrumentationOptions.postgreSql));
        }
        if ((_f = this._config.instrumentationOptions.redis) === null || _f === void 0 ? void 0 : _f.enabled) {
            this._instrumentations.push(new instrumentationRedis.RedisInstrumentation(this._config.instrumentationOptions.redis));
        }
        if ((_g = this._config.instrumentationOptions.redis4) === null || _g === void 0 ? void 0 : _g.enabled) {
            this._instrumentations.push(new instrumentationRedis4.RedisInstrumentation(this._config.instrumentationOptions.redis4));
        }
    }
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * Azure Monitor LogRecord Processor.
 * @internal
 */
class AzureLogRecordProcessor {
    constructor(metricHandler) {
        this._metricHandler = metricHandler;
    }
    onEmit(logRecord) {
        try {
            this._metricHandler.recordLog(logRecord);
        }
        catch (error) {
            Logger.getInstance().warn("Error while recording log", error);
        }
    }
    forceFlush() {
        return Promise.resolve();
    }
    shutdown() {
        return Promise.resolve();
    }
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * Azure Monitor BatchLogRecord Processor.
 * @internal
 */
class AzureBatchLogRecordProcessor extends sdkLogs.BatchLogRecordProcessor {
    constructor(exporter, options) {
        super(exporter);
        this._options = options;
    }
    onEmit(logRecord) {
        // Trace based sampling for logs
        if (this._options.enableTraceBasedSamplingForLogs) {
            if (logRecord.spanContext && logRecord.spanContext.spanId) {
                // eslint-disable-next-line @typescript-eslint/no-unsafe-enum-comparison
                if (logRecord.spanContext.traceFlags !== api.TraceFlags.SAMPLED) {
                    // Do not export log for spans that were sampled out
                    return;
                }
            }
        }
        super.onEmit(logRecord);
    }
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * Convert log level to severity number.
 * @internal
 */
function logLevelToSeverityNumber(logLevel) {
    let severityNumber = apiLogs.SeverityNumber.UNSPECIFIED;
    switch (logLevel) {
        case "ALL":
            severityNumber = apiLogs.SeverityNumber.UNSPECIFIED;
            break;
        case "DEBUG":
            severityNumber = apiLogs.SeverityNumber.DEBUG;
            break;
        case "ERROR":
            severityNumber = apiLogs.SeverityNumber.ERROR;
            break;
        case "INFO":
            severityNumber = apiLogs.SeverityNumber.INFO;
            break;
        case "VERBOSE":
            severityNumber = apiLogs.SeverityNumber.TRACE;
            break;
        case "WARN":
            severityNumber = apiLogs.SeverityNumber.WARN;
            break;
    }
    return severityNumber;
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * Azure Monitor OpenTelemetry Log Handler
 */
class LogHandler {
    /**
     * Initializes a new instance of the TraceHandler class.
     * @param _config - Distro configuration.
     * @param _metricHandler - MetricHandler.
     */
    constructor(config, metricHandler) {
        this._config = config;
        this._metricHandler = metricHandler;
        this._azureExporter = new monitorOpentelemetryExporter.AzureMonitorLogExporter(config.azureMonitorExporterOptions);
        this._azureBatchLogRecordProcessor = new AzureBatchLogRecordProcessor(this._azureExporter, {
            enableTraceBasedSamplingForLogs: this._config.enableTraceBasedSamplingForLogs,
        });
        this._azureLogRecordProcessor = new AzureLogRecordProcessor(this._metricHandler);
        this._instrumentations = [];
        this._initializeInstrumentations();
    }
    getAzureLogRecordProcessor() {
        return this._azureLogRecordProcessor;
    }
    getBatchLogRecordProcessor() {
        return this._azureBatchLogRecordProcessor;
    }
    getInstrumentations() {
        return this._instrumentations;
    }
    /**
     * Start auto collection of telemetry
     */
    _initializeInstrumentations() {
        var _a, _b;
        const logLevelEnv = process.env.APPLICATIONINSIGHTS_INSTRUMENTATION_LOGGING_LEVEL;
        if ((_a = this._config.instrumentationOptions.bunyan) === null || _a === void 0 ? void 0 : _a.enabled) {
            this._instrumentations.push(new instrumentationBunyan.BunyanInstrumentation(Object.assign(Object.assign({}, this._config.instrumentationOptions.bunyan), { logSeverity: logLevelEnv ? logLevelToSeverityNumber(logLevelEnv) : undefined })));
        }
        if ((_b = this._config.instrumentationOptions.winston) === null || _b === void 0 ? void 0 : _b.enabled) {
            this._instrumentations.push(new instrumentationWinston.WinstonInstrumentation(Object.assign(Object.assign({}, this._config.instrumentationOptions.winston), { logSeverity: logLevelEnv ? logLevelToSeverityNumber(logLevelEnv) : undefined })));
        }
    }
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/* eslint-disable @typescript-eslint/explicit-module-boundary-types */
// currently support the following encoding types
var contentEncodingMethod;
(function (contentEncodingMethod) {
    contentEncodingMethod["GZIP"] = "gzip";
    contentEncodingMethod["DEFLATE"] = "deflate";
    contentEncodingMethod["BR"] = "br";
})(contentEncodingMethod || (contentEncodingMethod = {}));
// for node version under 10, Brotli compression is not supported.
const isBrotliSupported = () => {
    const majVer = process.versions.node.split(".")[0];
    return parseInt(majVer) >= 10;
};
util.promisify(zlib__namespace.gzip);
util.promisify(zlib__namespace.gunzip);
util.promisify(zlib__namespace.deflate);
util.promisify(zlib__namespace.inflate);
// eslint-disable-next-line @typescript-eslint/no-unsafe-function-type
const getBrotliCompressSync = (zlibObject) => {
    const isMajorVer = isBrotliSupported();
    if (isMajorVer && typeof zlibObject.brotliCompressSync === "function") {
        // eslint-disable-next-line @typescript-eslint/no-unsafe-return
        return zlibObject.brotliCompressSync;
    }
    return null;
};
// eslint-disable-next-line @typescript-eslint/no-unsafe-function-type
const getBrotliDecompressSync = (zlibObject) => {
    const isMajorVer = isBrotliSupported();
    if (isMajorVer && typeof zlibObject.brotliDecompressSync === "function") {
        // eslint-disable-next-line @typescript-eslint/no-unsafe-return
        return zlibObject.brotliDecompressSync;
    }
    return null;
};
const isBufferType = (buffer, type) => {
    const encodingType = type ? type : "utf8";
    let result = false;
    if (Buffer.isEncoding(encodingType)) {
        const newBuffer = Buffer.from(buffer.toString(encodingType), encodingType);
        result = newBuffer.toJSON().data.toString() === buffer.toJSON().data.toString();
    }
    return result;
};
const isSupportedContentEncoding = (encodingMethod) => {
    let encodingType = null;
    switch (encodingMethod) {
        case "gzip":
            encodingType = contentEncodingMethod.GZIP;
            break;
        case "br":
            encodingType = contentEncodingMethod.BR;
            break;
        case "deflate":
            encodingType = contentEncodingMethod.DEFLATE;
            break;
    }
    return encodingType;
};
// mutiple content-encoding is not supported
// for mutiple content-encoding, this method will return any empty array
const getContentEncodingFromHeaders = (response) => {
    const headers = [];
    const contentEncodingHeaders = response.getHeader("Content-Encoding");
    if (!contentEncodingHeaders)
        return null;
    if (typeof contentEncodingHeaders === "string") {
        const supportedContentEncoding = isSupportedContentEncoding(contentEncodingHeaders);
        if (supportedContentEncoding) {
            headers.push(supportedContentEncoding);
        }
    }
    return headers;
};
const insertBrowserSdkLoaderByIndex = (index, html, snippet) => {
    if (index < 0)
        return null;
    let newHtml = null;
    const subStart = html.substring(0, index);
    const subEnd = html.substring(index);
    newHtml = subStart + '<script type="text/javascript">' + snippet + "</script>" + subEnd;
    return newHtml;
};
const isContentTypeHeaderHtml = (response) => {
    let isHtml = false;
    const contentType = response.getHeader("Content-Type");
    if (contentType) {
        if (typeof contentType === "string") {
            isHtml = contentType.indexOf("html") >= 0;
        }
        else {
            isHtml = contentType.toString().indexOf("html") >= 0;
        }
    }
    return isHtml;
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/* eslint-disable no-underscore-dangle*/
class BrowserSdkLoader {
    constructor(config) {
        var _a, _b;
        this._isIkeyValid = true;
        this._isInitialized = false;
        if (BrowserSdkLoader._instance) {
            api.diag.warn("Browser SDK Loader should be configured from the applicationInsights object");
        }
        BrowserSdkLoader._instance = this;
        // AI URL used to validate if sdk loader already included
        BrowserSdkLoader._aiUrl = BROWSER_SDK_LOADER_DEFAULT_SOURCE;
        let clientWebIkey;
        if ((_a = config.browserSdkLoaderOptions) === null || _a === void 0 ? void 0 : _a.connectionString) {
            clientWebIkey = this._getBrowserSdkLoaderIkey((_b = config === null || config === void 0 ? void 0 : config.browserSdkLoaderOptions) === null || _b === void 0 ? void 0 : _b.connectionString);
        }
        this._browserSdkLoaderIkey =
            clientWebIkey ||
                ConnectionStringParser.parse(config.azureMonitorExporterOptions.connectionString)
                    .instrumentationkey;
        if (this._isIkeyValid) {
            this._initialize();
        }
    }
    isInitialized() {
        return this._isInitialized;
    }
    static getInstance() {
        return BrowserSdkLoader._instance;
    }
    _getBrowserSdkLoaderIkey(connectionString) {
        let iKey = null;
        try {
            const csCode = ConnectionStringParser.parse(connectionString);
            const iKeyCode = csCode.instrumentationkey || "";
            if (!ConnectionStringParser.validateInstrumentationKey(iKeyCode)) {
                this._isIkeyValid = false;
                Logger.getInstance().info("Invalid browser SDK loader connection string, browser SDK loader is not enabled.");
            }
            else {
                this._isIkeyValid = true;
                iKey = iKeyCode;
            }
        }
        catch (err) {
            Logger.getInstance().info(`get browser SDK loader ikey error: ${err}`);
        }
        return iKey;
    }
    /**
     * Gets string to inject into the web page
     * @returns The string to inject into the web page
     */
    _getBrowserSdkLoaderReplacedStr() {
        const osStr = getOsPrefix();
        const rpStr = getResourceProvider();
        const sdkLoaderReplacedStr = `${this._browserSdkLoaderIkey}",\r\n disableIkeyDeprecationMessage: true,\r\n sdkExtension: "${rpStr}${osStr}d_n_`;
        const replacedSdkLoader = applicationinsightsWebSnippet.webSnippet.replace("INSTRUMENTATION_KEY", sdkLoaderReplacedStr);
        return replacedSdkLoader;
    }
    _initialize() {
        this._isInitialized = true;
        BrowserSdkLoader._sdkLoader = this._getBrowserSdkLoaderReplacedStr();
        const originalHttpServer = http.createServer;
        const originalHttpsServer = https.createServer;
        http.createServer = (requestListener) => {
            const originalRequestListener = requestListener;
            if (originalRequestListener) {
                requestListener = (request, response) => {
                    // Patch response write method
                    // eslint-disable-next-line @typescript-eslint/unbound-method
                    const originalResponseWrite = response.write;
                    const isGetRequest = request.method === "GET";
                    // eslint-disable-next-line @typescript-eslint/no-unsafe-function-type
                    response.write = function wrap(a, b) {
                        var _a, _b;
                        // only patch GET request
                        try {
                            if (isGetRequest) {
                                const headers = getContentEncodingFromHeaders(response);
                                let writeBufferType = undefined;
                                if (typeof b === "string") {
                                    writeBufferType = b;
                                }
                                if (headers === null || headers === undefined) {
                                    if ((_a = BrowserSdkLoader._instance) === null || _a === void 0 ? void 0 : _a.ValidateInjection(response, a)) {
                                        // eslint-disable-next-line prefer-rest-params
                                        arguments[0] = BrowserSdkLoader._instance.InjectSdkLoader(response, a, undefined, writeBufferType);
                                    }
                                }
                                else if (headers.length) {
                                    const encodeType = headers[0];
                                    // eslint-disable-next-line prefer-rest-params
                                    arguments[0] = (_b = BrowserSdkLoader._instance) === null || _b === void 0 ? void 0 : _b.InjectSdkLoader(response, a, encodeType);
                                }
                            }
                        }
                        catch (err) {
                            Logger.getInstance().warn(`Inject browser sdk loader error: ${err}`);
                        }
                        // eslint-disable-next-line prefer-rest-params
                        return originalResponseWrite.apply(response, arguments);
                    };
                    // Patch response end method for cases when HTML is added there
                    // eslint-disable-next-line @typescript-eslint/unbound-method
                    const originalResponseEnd = response.end;
                    // eslint-disable-next-line @typescript-eslint/no-unsafe-function-type, @typescript-eslint/no-redundant-type-constituents
                    response.end = function wrap(a, b) {
                        var _a, _b;
                        if (isGetRequest) {
                            try {
                                if (isGetRequest) {
                                    const headers = getContentEncodingFromHeaders(response);
                                    let endBufferType = undefined;
                                    if (typeof b === "string") {
                                        endBufferType = b;
                                    }
                                    if (headers === null || headers === undefined) {
                                        if ((_a = BrowserSdkLoader._instance) === null || _a === void 0 ? void 0 : _a.ValidateInjection(response, a)) {
                                            // eslint-disable-next-line prefer-rest-params
                                            arguments[0] = BrowserSdkLoader._instance.InjectSdkLoader(response, a, undefined, endBufferType);
                                        }
                                    }
                                    else if (headers.length) {
                                        const encodeType = headers[0];
                                        // eslint-disable-next-line prefer-rest-params
                                        arguments[0] = (_b = BrowserSdkLoader._instance) === null || _b === void 0 ? void 0 : _b.InjectSdkLoader(response, a, encodeType);
                                    }
                                }
                            }
                            catch (err) {
                                Logger.getInstance().warn(`Inject browser sdk loader error: ${err}`);
                            }
                        }
                        // eslint-disable-next-line prefer-rest-params
                        return originalResponseEnd.apply(response, arguments);
                    };
                    return originalRequestListener(request, response);
                };
            }
            return originalHttpServer(requestListener);
        };
        https.createServer = function (options, httpsRequestListener) {
            const originalHttpsRequestListener = httpsRequestListener;
            if (originalHttpsRequestListener) {
                httpsRequestListener = function (req, res) {
                    const isGetHttpsRequest = req.method === "GET";
                    const originalHttpsResponseWrite = res.write;
                    const originalHttpsResponseEnd = res.end;
                    // eslint-disable-next-line @typescript-eslint/no-unsafe-function-type, @typescript-eslint/no-redundant-type-constituents
                    res.write = function wrap(a, b) {
                        var _a, _b;
                        try {
                            if (isGetHttpsRequest) {
                                const headers = getContentEncodingFromHeaders(res);
                                let writeBufferType = undefined;
                                if (typeof b === "string") {
                                    writeBufferType = b;
                                }
                                if (headers === null || headers === undefined) {
                                    if ((_a = BrowserSdkLoader._instance) === null || _a === void 0 ? void 0 : _a.ValidateInjection(res, a)) {
                                        // eslint-disable-next-line prefer-rest-params
                                        arguments[0] = this.InjectSdkLoader(res, a, undefined, writeBufferType);
                                    }
                                }
                                else if (headers.length) {
                                    const encodeType = headers[0];
                                    // eslint-disable-next-line prefer-rest-params
                                    arguments[0] = (_b = BrowserSdkLoader._instance) === null || _b === void 0 ? void 0 : _b.InjectSdkLoader(res, a, encodeType);
                                }
                            }
                        }
                        catch (err) {
                            Logger.getInstance().warn(`Inject SDK loader error: ${err}`);
                        }
                        // eslint-disable-next-line prefer-rest-params, @typescript-eslint/no-unsafe-return
                        return originalHttpsResponseWrite.apply(res, arguments);
                    };
                    // eslint-disable-next-line @typescript-eslint/no-unsafe-function-type, @typescript-eslint/no-redundant-type-constituents
                    res.end = function wrap(a, b) {
                        var _a, _b;
                        try {
                            if (isGetHttpsRequest) {
                                const headers = getContentEncodingFromHeaders(res);
                                let endBufferType = undefined;
                                if (typeof b === "string") {
                                    endBufferType = b;
                                }
                                if (headers === null || headers === undefined) {
                                    if ((_a = BrowserSdkLoader._instance) === null || _a === void 0 ? void 0 : _a.ValidateInjection(res, a)) {
                                        // eslint-disable-next-line prefer-rest-params
                                        arguments[0] = BrowserSdkLoader._instance.InjectSdkLoader(res, a, undefined, endBufferType);
                                    }
                                }
                                else if (headers.length) {
                                    const encodeType = headers[0];
                                    // eslint-disable-next-line prefer-rest-params
                                    arguments[0] = (_b = BrowserSdkLoader._instance) === null || _b === void 0 ? void 0 : _b.InjectSdkLoader(res, a, encodeType);
                                }
                            }
                        }
                        catch (err) {
                            Logger.getInstance().warn(`Inject SDK loader error: ${err}`);
                        }
                        // eslint-disable-next-line prefer-rest-params, @typescript-eslint/no-unsafe-return
                        return originalHttpsResponseEnd.apply(res, arguments);
                    };
                    // eslint-disable-next-line @typescript-eslint/no-unsafe-return
                    return originalHttpsRequestListener(req, res);
                };
                return originalHttpsServer(options, httpsRequestListener);
            }
        };
    }
    /**
     * Validate response and try to inject Browser SDK Loader
     */
    // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
    ValidateInjection(response, input) {
        try {
            if (!response || !input || response.statusCode !== 200)
                return false;
            const isContentHtml = isContentTypeHeaderHtml(response);
            if (!isContentHtml)
                return false;
            const inputStr = input.slice().toString();
            if (inputStr.indexOf("<head>") >= 0 && inputStr.indexOf("</head>") >= 0) {
                // Check if sdk loader not already present looking for AI Web SDK URL
                if (inputStr.indexOf(BrowserSdkLoader._aiUrl) < 0) {
                    return true;
                }
            }
        }
        catch (err) {
            Logger.getInstance().info(`validate injections error: ${err}`);
        }
        return false;
    }
    /**
     * Inject Browser SDK Loader
     */
    InjectSdkLoader(
    // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
    response, input, encodeType, bufferEncodeType) {
        try {
            const isCompressedBuffer = !!encodeType;
            if (!isCompressedBuffer) {
                const html = input.toString();
                const index = html.indexOf("</head>");
                if (index < 0)
                    return input;
                const newHtml = insertBrowserSdkLoaderByIndex(index, html, BrowserSdkLoader._sdkLoader);
                if (typeof input === "string") {
                    response.removeHeader("Content-Length");
                    if (newHtml) {
                        input = newHtml;
                    }
                    response.setHeader("Content-Length", Buffer.byteLength(input));
                }
                else if (Buffer.isBuffer(input)) {
                    const bufferType = bufferEncodeType ? bufferEncodeType : "utf8";
                    const isValidBufferType = isBufferType(input, bufferType);
                    if (isValidBufferType && newHtml) {
                        response.removeHeader("Content-Length");
                        const encodedString = Buffer.from(newHtml).toString(bufferType);
                        input = Buffer.from(encodedString, bufferType);
                        response.setHeader("Content-Length", input.length);
                    }
                }
            }
            else {
                response.removeHeader("Content-Length");
                input = this._getInjectedCompressBuffer(response, input, encodeType);
                response.setHeader("Content-Length", input.length);
            }
        }
        catch (ex) {
            Logger.getInstance().warn(`Failed to inject browser sdk loader and change content-length headers. Exception:${ex}`);
        }
        return input;
    }
    //* **********************
    // should NOT use sync functions here. But currently cannot get async functions to work
    // because reponse.write return boolean
    // and also this function do not support partial compression as well
    // need more investigation
    _getInjectedCompressBuffer(response, input, encodeType) {
        try {
            switch (encodeType) {
                case contentEncodingMethod.GZIP: {
                    const gunzipBuffer = zlib__namespace.gunzipSync(input);
                    if (this.ValidateInjection(response, gunzipBuffer)) {
                        const injectedGunzipBuffer = this.InjectSdkLoader(response, gunzipBuffer);
                        input = zlib__namespace.gzipSync(injectedGunzipBuffer);
                    }
                    break;
                }
                case contentEncodingMethod.DEFLATE: {
                    const inflateBuffer = zlib__namespace.inflateSync(input);
                    if (this.ValidateInjection(response, inflateBuffer)) {
                        const injectedInflateBuffer = this.InjectSdkLoader(response, inflateBuffer);
                        input = zlib__namespace.deflateSync(injectedInflateBuffer);
                    }
                    break;
                }
                case contentEncodingMethod.BR: {
                    const BrotliDecompressSync = getBrotliDecompressSync(zlib__namespace);
                    const BrotliCompressSync = getBrotliCompressSync(zlib__namespace);
                    if (BrotliDecompressSync && BrotliCompressSync) {
                        const decompressBuffer = BrotliDecompressSync(input);
                        if (this.ValidateInjection(response, decompressBuffer)) {
                            const injectedDecompressBuffer = this.InjectSdkLoader(response, decompressBuffer);
                            input = BrotliCompressSync(injectedDecompressBuffer);
                        }
                        break;
                    }
                }
            }
        }
        catch (err) {
            Logger.getInstance().info(`get browser SDK loader compress buffer error: ${err}`);
        }
        return input;
    }
    dispose() {
        BrowserSdkLoader._instance = null;
        this._isInitialized = false;
    }
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * Patch OpenTelemetry Instrumentation enablement to update the statsbeat environment variable with the enabled instrumentations
 * @internal
 */
function patchOpenTelemetryInstrumentationEnable() {
    const emptyStatsbeatConfig = JSON.stringify({ instrumentation: 0, feature: 0 });
    try {
        require.resolve("@opentelemetry/instrumentation");
        // eslint-disable-next-line @typescript-eslint/no-require-imports
        const autoLoaderUtils = require("@opentelemetry/instrumentation/build/src/autoLoaderUtils");
        const originalModuleDefinition = autoLoaderUtils.enableInstrumentations;
        // Parses the enabled instrumentations and then ammends the statsbeat instrumentation environment variable
        autoLoaderUtils.enableInstrumentations = function (instrumentations) {
            try {
                const statsbeatOptions = JSON.parse(process.env[AZURE_MONITOR_STATSBEAT_FEATURES] || emptyStatsbeatConfig);
                let updatedStatsbeat = {};
                for (let i = 0; i < instrumentations.length; i++) {
                    updatedStatsbeat = {
                        instrumentation: (statsbeatOptions.instrumentation |=
                            StatsbeatInstrumentationMap.get(instrumentations[i].instrumentationName) || 0),
                        feature: statsbeatOptions.feature,
                    };
                }
                process.env[AZURE_MONITOR_STATSBEAT_FEATURES] = JSON.stringify(updatedStatsbeat);
            }
            catch (e) {
                Logger.getInstance().warn("Failed to parse the statsbeat environment variable");
            }
            // eslint-disable-next-line @typescript-eslint/no-unsafe-return, prefer-rest-params
            return originalModuleDefinition.apply(this, arguments);
        };
    }
    catch (e) {
        // Fail silently if the module is not found
    }
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
process.env["AZURE_MONITOR_DISTRO_VERSION"] = AZURE_MONITOR_OPENTELEMETRY_VERSION;
let sdk;
let browserSdkLoader;
/**
 * Initialize Azure Monitor Distro
 * @param options - Azure Monitor OpenTelemetry Options
 */
function useAzureMonitor(options) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r;
    const config = new InternalConfig(options);
    patchOpenTelemetryInstrumentationEnable();
    const statsbeatInstrumentations = {
        // Instrumentations
        azureSdk: (_b = (_a = config.instrumentationOptions) === null || _a === void 0 ? void 0 : _a.azureSdk) === null || _b === void 0 ? void 0 : _b.enabled,
        mongoDb: (_d = (_c = config.instrumentationOptions) === null || _c === void 0 ? void 0 : _c.mongoDb) === null || _d === void 0 ? void 0 : _d.enabled,
        mySql: (_f = (_e = config.instrumentationOptions) === null || _e === void 0 ? void 0 : _e.mySql) === null || _f === void 0 ? void 0 : _f.enabled,
        postgreSql: (_h = (_g = config.instrumentationOptions) === null || _g === void 0 ? void 0 : _g.postgreSql) === null || _h === void 0 ? void 0 : _h.enabled,
        redis: (_k = (_j = config.instrumentationOptions) === null || _j === void 0 ? void 0 : _j.redis) === null || _k === void 0 ? void 0 : _k.enabled,
        bunyan: (_m = (_l = config.instrumentationOptions) === null || _l === void 0 ? void 0 : _l.bunyan) === null || _m === void 0 ? void 0 : _m.enabled,
        winston: (_p = (_o = config.instrumentationOptions) === null || _o === void 0 ? void 0 : _o.winston) === null || _p === void 0 ? void 0 : _p.enabled,
    };
    const statsbeatFeatures = {
        browserSdkLoader: config.browserSdkLoaderOptions.enabled,
        aadHandling: !!((_q = config.azureMonitorExporterOptions) === null || _q === void 0 ? void 0 : _q.credential),
        diskRetry: !((_r = config.azureMonitorExporterOptions) === null || _r === void 0 ? void 0 : _r.disableOfflineStorage),
    };
    getInstance().setStatsbeatFeatures(statsbeatInstrumentations, statsbeatFeatures);
    if (config.browserSdkLoaderOptions.enabled) {
        browserSdkLoader = new BrowserSdkLoader(config);
    }
    // Remove global providers in OpenTelemetry, these would be overridden if present
    api.metrics.disable();
    api.trace.disable();
    apiLogs.logs.disable();
    // Create internal handlers
    const metricHandler = new MetricHandler(config);
    const traceHandler = new TraceHandler(config, metricHandler);
    const logHandler = new LogHandler(config, metricHandler);
    const instrumentations = traceHandler
        .getInstrumentations()
        .concat(logHandler.getInstrumentations());
    const resourceDetectorsList = parseResourceDetectorsFromEnvVar();
    // Add extra SpanProcessors, and logRecordProcessors from user configuration
    const spanProcessors = (options === null || options === void 0 ? void 0 : options.spanProcessors) || [];
    const logRecordProcessors = (options === null || options === void 0 ? void 0 : options.logRecordProcessors) || [];
    // Initialize OpenTelemetry SDK
    const sdkConfig = {
        autoDetectResources: true,
        metricReader: metricHandler.getMetricReader(),
        views: metricHandler.getViews(),
        instrumentations: instrumentations,
        logRecordProcessors: [
            logHandler.getAzureLogRecordProcessor(),
            ...logRecordProcessors,
            logHandler.getBatchLogRecordProcessor(),
        ],
        resource: config.resource,
        sampler: traceHandler.getSampler(),
        spanProcessors: [
            traceHandler.getAzureMonitorSpanProcessor(),
            ...spanProcessors,
            traceHandler.getBatchSpanProcessor(),
        ],
        resourceDetectors: resourceDetectorsList,
    };
    sdk = new sdkNode.NodeSDK(sdkConfig);
    setSdkPrefix();
    sdk.start();
}
/**
 * Shutdown Azure Monitor Open Telemetry Distro
 * @see https://github.com/open-telemetry/opentelemetry-js/blob/0229434cb5a3179f63c021105f36270ae7897929/experimental/packages/opentelemetry-sdk-node/src/sdk.ts#L398
 */
function shutdownAzureMonitor() {
    browserSdkLoader === null || browserSdkLoader === void 0 ? void 0 : browserSdkLoader.dispose();
    return sdk === null || sdk === void 0 ? void 0 : sdk.shutdown();
}

exports.shutdownAzureMonitor = shutdownAzureMonitor;
exports.useAzureMonitor = useAzureMonitor;
//# sourceMappingURL=index.js.map
